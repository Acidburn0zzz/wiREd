!global.traceur && (0,eval)(require('fs').readFileSync(__dirname+'/../deps/traceur-compiler/bin/traceur.js', 'utf8'));
var $__0 = Object.freeze(Object.defineProperties(["if(typeof a === 'object' && 'value' in a) a = a.value;"], {raw: {value: Object.freeze(["if(typeof a === 'object' && 'value' in a) a = a.value;"])}})), $__1 = Object.freeze(Object.defineProperties(["if(typeof b === 'object' && 'value' in b) b = b.value;"], {raw: {value: Object.freeze(["if(typeof b === 'object' && 'value' in b) b = b.value;"])}})), $__2 = Object.freeze(Object.defineProperties(["if(!a) return b;"], {raw: {value: Object.freeze(["if(!a) return b;"])}})), $__3 = Object.freeze(Object.defineProperties(["if(!b) return a;"], {raw: {value: Object.freeze(["if(!b) return a;"])}})), $__4 = Object.freeze(Object.defineProperties(["if(a === b) return 0;"], {raw: {value: Object.freeze(["if(a === b) return 0;"])}})), $__5 = Object.freeze(Object.defineProperties(["if(a === b) return a;"], {raw: {value: Object.freeze(["if(a === b) return a;"])}})), $__6 = Object.freeze(Object.defineProperties(["if(known(a) && known(b)) return a ", " b;"], {raw: {value: Object.freeze(["if(known(a) && known(b)) return a ", " b;"])}})), $__7 = Object.freeze(Object.defineProperties(["if(a.op == '+' && known(a.b) && known(b)) return Add(a.a, a.b+b);"], {raw: {value: Object.freeze(["if(a.op == '+' && known(a.b) && known(b)) return Add(a.a, a.b+b);"])}}));
var fs = require('fs'), util = require('util');
function inspect(x, p) {
  if (known(x) && x > 100) return '0x' + x.toString(16);
  if (typeof x === 'object' && x.inspect) return x.inspect(0, p || 16);
  return util.inspect(x);
}
function known(x) {
  return typeof x === 'number';
}
function runtimeKnown(x) {
  return known(x) || x.runtimeKnown;
}
function bitsof(x, fatal) {
  if (typeof x === 'object' && known(x.bitsof)) return x.bitsof;
  if (fatal) throw new TypeError('Missing bit size for ' + inspect(x)); else console.error('Missing bit size for ' + inspect(x));
}
function sizeof(x, fatal) {
  if (known(x = bitsof(x, fatal))) return Math.ceil(x / 8);
}
var codeGen = exports.codeGen = function codeGen(x) {
  if (known(x)) return x.toString();
  if (!x || !x.codeGen) throw new TypeError('Invalid codeGen source ' + inspect(x));
  return x.codeGen();
};
codeGen.runtime = ["var util = require('util');", "var known = exports.known = function known(x) {\n        return typeof x === 'number';\n    }", "var inspect = exports.inspect = function inspect(x, p) {\n        if(known(x) && x > 100)\n            return '0x'+x.toString(16);\n        if(typeof x === 'object' && x.inspect)\n            return x.inspect(0, p || 16);\n        return util.inspect(x);\n    }"];
var exportedFn = {
  inspect: inspect,
  known: known,
  runtimeKnown: runtimeKnown,
  bitsof: bitsof,
  sizeof: sizeof
};
var precendence = {
  '()': 1,
  '[]': 1,
  '~': 2,
  '*': 3,
  '/': 3,
  '%': 3,
  '+': 4,
  '-': 4,
  '<<': 5,
  '>>': 5,
  '>>>': 5,
  '<': 6,
  '==': 7,
  '&': 8,
  '^': 9,
  '|': 10,
  '=': 13,
  ',': 14
};
'Interrupt,If,Nop'.split(',').forEach(function(fn) {
  traceur.runtime.elementSet(exportedFn, fn, (function() {
    var args = Array.prototype.slice.call(arguments, 0);
    return ({
      inspect: (function() {
        return fn + '(' + args.map((function(x) {
          return inspect(x);
        })).join(', ') + ')';
      }),
      codeGen: (function() {
        return fn + '(' + args.map((function(x) {
          return codeGen(x);
        })).join(', ') + ')';
      }),
      runtimeKnown: false
    });
  }));
  codeGen.runtime.push(("function " + fn + "() {\n    var args = [].slice.call(arguments);\n    return {\n        fn: '" + fn + "', args: args,\n        inspect: function() {\n            return '" + fn + "('+args.map(function(x) {return inspect(typeof x === 'object' && 'value' in x ? x.value : x);}).join(', ')+')';\n        }\n    };\n}"));
});
exportedFn.Ext = function(a) {
  var bits = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): 32;
  var bitsa = traceur.runtime.elementGet(arguments, 2) !== (void 0) ? traceur.runtime.elementGet(arguments, 2): bitsof(a, true);
  if (bitsa <= bits) {
    a = Object.create(a);
    a.bitsof = bits;
    return a;
  }
  throw new TypeError;
};
exportedFn.ExtS = function(a) {
  var bits = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): 32;
  var bitsa = traceur.runtime.elementGet(arguments, 2) !== (void 0) ? traceur.runtime.elementGet(arguments, 2): bitsof(a, true);
  if (bitsa <= bits) {
    a = ASR(LSL(a, bits - bitsa), bits - bitsa);
    a.bitsof = bits;
    return a;
  }
  throw new TypeError;
};
exportedFn.Mem = (function(addr, size) {
  return ({
    fn: 'Mem',
    addr: addr,
    size: size,
    bitsof: size && size * 8,
    inspect: (function() {
      return '[' + inspect(addr) + ']' + (traceur.runtime.elementGet([, 'b', 'w',, 'dw',,,, 'qw'], + size) || '');
    }),
    codeGen: (function() {
      return 'Mem(' + codeGen(addr) + (size ? ', ' + size: '') + ')';
    }),
    runtimeKnown: false
  });
});
codeGen.runtime.push("function Mem(addr, size) {\n    if(typeof addr === 'object' && 'value' in addr) addr = addr.value;\n    return {\n        fn: 'Mem', addr: addr, size: size,\n        inspect: function() {\n            return '['+inspect(addr)+']'+([,'b','w',,'dw',,,,'qw'][+size] || '');\n        }\n    };\n}");
exportedFn.Not = (function(a) {
  return ({
    fn: 'Not',
    op: '~',
    a: a,
    bitsof: bitsof(a),
    inspect: (function() {
      return '~' + inspect(a, traceur.runtime.elementGet(precendence, '~'));
    }),
    codeGen: function() {
      return this.runtimeKnown ? '~' + codeGen(a): 'Not(' + codeGen(a) + ')';
    },
    runtimeKnown: runtimeKnown(a)
  });
});
codeGen.runtime.push(("function Not(a) {\n    if(typeof a === 'object' && 'value' in a) a = a.value;\n    return {\n        fn: 'Not', op: '~', a: a,\n        inspect: function(_, p) {\n            var expr = '~'+inspect(a, " + traceur.runtime.elementGet(precendence, '~') + ");\n            return " + traceur.runtime.elementGet(precendence, '~') + " <= p ? expr : '('+expr+')';\n        }\n    };\n}"));
exportedFn.Neg = (function(a) {
  return ({
    fn: 'Neg',
    op: '-',
    a: a,
    bitsof: bitsof(a),
    inspect: (function() {
      return '-' + inspect(a, traceur.runtime.elementGet(precendence, '~'));
    }),
    codeGen: function() {
      return this.runtimeKnown ? '-' + codeGen(a): 'Neg(' + codeGen(a) + ')';
    },
    runtimeKnown: runtimeKnown(a)
  });
});
codeGen.runtime.push(("function Neg(a) {\n    if(typeof a === 'object' && 'value' in a) a = a.value;\n    if(known(a))\n        return -a;\n    return {\n        fn: 'Neg', op: '-', a: a,\n        inspect: function(_, p) {\n            var expr = '-'+inspect(a, " + traceur.runtime.elementGet(precendence, '~') + ");\n            return " + traceur.runtime.elementGet(precendence, '~') + " <= p ? expr : '('+expr+')';\n        }\n    };\n}"));
exportedFn.Sub = (function(a, b) {
  return Add(a, Neg(b));
});
var binaryOps = {
  Mov: '=',
  Swap: '<->',
  Add: '+',
  Mul: '*',
  And: '&',
  Or: '|',
  Xor: '^',
  Eq: '==',
  Lt: '<',
  LSL: '<<',
  LSR: '>>>',
  ASR: '>>',
  ROR: 'ROR',
  ROL: 'ROL'
};
Object.keys(binaryOps).forEach(function(fn) {
  var op = traceur.runtime.elementGet(binaryOps, fn), prec = traceur.runtime.elementGet(precendence, op);
  var prologue = '', p = (function(s) {
    var args = Array.prototype.slice.call(arguments, 1);
    return prologue += '\n    ' + s.map((function(x, i) {
      return i ? traceur.runtime.elementGet(args, i - 1) + x: x;
    })).join('');
  });
  if (op != '=' && op != '<->') p($__0);
  if (op != '<->') p($__1);
  if (op == '+') {
    p($__2);
  }
  if (op == '+' || op == '^' || op == '<<' || op == '>>' || op == '>>>' || op == 'ROR' || op == 'ROL') p($__3);
  if (op == '^') p($__4);
  if (op == '&' || op == '|') p($__5);
  if (op == '+') p($__6, op);
  if (op == '+') p($__7);
  var prologueFn = eval(("(function(a, b) {" + prologue + " return [a, b];})"));
  traceur.runtime.elementSet(exportedFn, fn, function(a, b) {
    var $__8;
    var o = prologueFn(a, b);
    if (!Array.isArray(o)) return o;
    ($__8 = o, a = traceur.runtime.elementGet($__8, 0), b = traceur.runtime.elementGet($__8, 1), $__8);
    var bitsa = bitsof(a), bitsb = bitsof(b);
    o = {
      fn: fn,
      op: op,
      a: a,
      b: b,
      inspect: function(_, p) {
        var op = this.op, a = this.a, b = this.b;
        if (op == '+' && b < 0) op = '-', b = - b;
        if (op == '=' && (b.op == '+' || b.op == '-' || b.op == '*' || b.op == '^' || b.op == '<<' || b.op == '>>' || b.op == '>>>') && b.a === a) {
          op = b.op + '=';
          b = b.b;
        }
        var expr = inspect(a, prec) + ' ' + op + ' ' + inspect(b, prec);
        return prec <= p ? expr: '(' + expr + ')';
      },
      codeGen: function() {
        if (!this.runtimeKnown) return fn + '(' + codeGen(a) + ', ' + codeGen(b) + ')';
        if (op == 'ROR') return codeGen(Or(LSR(a, b), LSL(a, Sub(32, b))));
        if (op == 'ROL') return codeGen(Or(LSR(a, Sub(32, b)), LSL(a, b)));
        return '(' + codeGen(a) + ' ' + op + ' ' + codeGen(b) + ')';
      },
      runtimeKnown: runtimeKnown(a) && runtimeKnown(b),
      CF: 0,
      NF: 0,
      OF: 0
    };
    var shiftOrRot = op == '<<' || op == '>>' || op == '>>>' || op == 'ROL' || op == 'ROR';
    if (op == '==' || op == '<') o.bitsof = 1; else if (known(bitsa) && (shiftOrRot || known(b) || known(bitsb))) {
      if (!shiftOrRot && bitsa != bitsb) {
        console.error(fn + ' called with differently sizeof operands (' + bitsa + ', ' + bitsb + '): ' + inspect(a) + ', ' + inspect(b));
        if (bitsb > bitsa) bitsa = bitsb;
      }
      o.bitsof = bitsa;
    }
    if (op == '+' && b.fn == 'Neg') {
      o.ZF = Eq(a, b.a);
      o.CF = Lt(a, b.a);
    } else if (op != '==' && op != '<') {
      o.ZF = Eq(o, 0);
      o.NF = Lt(o, 0);
    }
    return o;
  });
  codeGen.runtime.push(("var " + fn + " = exports." + fn + " = function " + fn + "(a, b) {" + prologue + "\n    return {\n        fn: '" + fn + "', op: '" + op + "', a: a, b: b,\n        inspect: function(_, p) {\n            var a = this.a, b = this.b;" + (op == '=' || op == '+' ? ("\n            var op = '" + op + "';\n            "): '') + (op == '+' ? "if(b < 0) {\n                op = '-';\n                b = -b;\n            }": '') + (op == '=' ? "if((b.op == '+' || b.op == '-' || b.op == '*' || b.op == '^' || b.op == '<<' || b.op == '>>' || b.op == '>>>') && b.a === a) {\n                op = b.op+'=';\n                b = b.b;\n            }": '') + "var expr = inspect(a, " + prec + ")+' " + (op == '=' || op == '+' ? "'+op+'": op) + " '+inspect(b, " + prec + ");\n            return " + prec + " <= p ? expr : '('+expr+')';\n        }\n    };\n}"));
});
for (var i in exportedFn) traceur.runtime.elementSet(global, i, traceur.runtime.elementGet(exportedFn, i));
exports.filters = {};
function Var(name, pos, len, bigEndian) {
  return {
    name: name,
    pos: pos,
    len: len,
    bitsof: len,
    posAt: function(d) {
      if (!(d >= 0 && d < this.len)) throw new RangeError('Offset ' + d + ' is outside the bit range');
      d += this.pos & 7;
      var pos = (this.pos & ~7) + (d & 7);
      if (bigEndian) return pos - (d & ~7);
      return pos + (d & ~7);
    },
    inspect: function() {
      return '<' + this.pos + (this.len > 1 ? ':' + (this.pos + this.len - 1): '') + '>';
    },
    codeGen: function() {
      if (this.len > 32) throw new RangeError('Too many (' + this.len + ') bits to decode');
      var bytes = [];
      var pos = this.pos & ~7, bits = this.pos & 7;
      var end = this.pos + this.len, endBits = end & 7;
      if (bits) {
        bytes.push('((b[i+' + (pos >>> 3) + '] & 0x' + (((1 << Math.min(this.len, 8 - bits)) - 1) << bits).toString(16) + ')>>>' + bits + ')');
        pos += 8;
      }
      for (var j = pos >>> 3; pos + 8 <= end; pos += 8, j += (bigEndian ? - 1: 1)) bytes.push(pos > this.pos ? '(b[i+' + j + ']<<' + (pos - this.pos) + ')': 'b[i+' + j + ']');
      if (pos < end) bytes.push(pos > this.pos ? '((b[i+' + j + '] & 0x' + ((1 << endBits) - 1).toString(16) + ')<<' + (pos - this.pos) + ')': '(b[i+' + j + '] & 0x' + ((1 << endBits) - 1).toString(16) + ')');
      return '(' + bytes.join('|') + ')';
    },
    runtimeKnown: true,
    slice: function(name, start, end) {
      if (typeof start !== 'number') start = 0; else if (start < 0) start += this.len;
      if (typeof end !== 'number') end = this.len; else if (end < 0) end += this.len;
      return Var(name, this.posAt(start), end - start, bigEndian);
    },
    filter: traceur.runtime.elementGet(exports.filters, name) || traceur.runtime.elementGet(exports.filters, name[0]) || function(next, ct) {
      if (this.len === 1) return next(traceur.runtime.elementSet(ct, this.pos, 0)), next(traceur.runtime.elementSet(ct, this.pos, 1));
      next(this);
    }
  };
}
exports.totals = 0;
exports.maps = {};
exports.op = function op(def, fn) {
  var self = this;
  var ct = [], vars = [], nBits = 0;
  def.forEach(function(x) {
    var n = x.length, bits = x.match(/[A-Z][a-z$]*_*|./g);
    if (n & 7) throw new TypeError('Opcode definition ' + x + ' does not align to a byte boundary');
    var part = Var(' ', nBits + (self.bigEndian ? n - 8: 0), n, self.bigEndian);
    for (var i = 0, j = n; i < bits.length && j > 0; i++) {
      var b = traceur.runtime.elementGet(bits, i);
      if (b === '0' || b === '1') traceur.runtime.elementSet(ct, part.posAt(j - 1), + b); else vars.push(part.slice(b.replace(/_+/g, ''), j - b.length, j));
      j -= b.length;
    }
    nBits += n;
  });
  function make(ct, vals) {
    var res = fn.apply(this, vals);
    if (!res) return;
    res = res.filter((function(x) {
      return x;
    }));
    function niceCT(ct) {
      var s = '';
      for (var i = nBits - 1; i >= 0; i--) s += typeof traceur.runtime.elementGet(ct, i) === 'number' ? traceur.runtime.elementGet(ct, i): 'x';
      return s;
    }
    ct = niceCT(ct);
    var ctMask = ct.replace(/[01]/g, 'K');
    self.totals += Math.pow(2, ct.split('').reduce((function(a, b) {
      return a + (b == 'x');
    }), 0));
    if (!traceur.runtime.elementGet(self.maps, ctMask)) traceur.runtime.elementSet(self.maps, ctMask, {$ct: ct}); else traceur.runtime.elementGet(self.maps, ctMask).$ct = traceur.runtime.elementGet(self.maps, ctMask).$ct.split('').map((function(x, i) {
      return x == traceur.runtime.elementGet(ct, i) ? x: 'K';
    })).join('');
    traceur.runtime.elementSet(traceur.runtime.elementGet(self.maps, ctMask), ct, res);
    console.log.apply(console, [ct + ':'].concat(res));
  }
  var vals = [];
  vals.byName = {};
  (function back(i, ct) {
    ct = ct.slice();
    if (i >= vars.length) return make(ct, vals);
    var v = traceur.runtime.elementGet(vars, i), name = v.name;
    Var(name, v.pos, v.len, this.bigEndian).filter((function(v, ct2) {
      traceur.runtime.elementSet(vals, i, traceur.runtime.elementSet(vals.byName, name, v));
      back(i + 1, ct2 || ct);
    }), ct, i, vals);
  })(0, ct);
  console.log();
};
exports.out = function out(outFile, fn) {
  console.log('Totals', this.totals, '0x' + this.totals.toString(16), Math.round(this.totals / (1 << 28) * 1000) / 10 + '%');
  console.log('{');
  var self = this;
  var mapKeys = Object.keys(self.maps).map((function(x) {
    return [traceur.runtime.elementGet(self.maps, x), traceur.runtime.elementGet(self.maps, x).$ct.split('').map((function(x) {
      return traceur.runtime.elementGet(({
        '0': 0,
        '1': 1,
        K: 2
      }), x);
    }))];
  }));
  mapKeys.sort((function(_a, _b) {
    var a = traceur.runtime.elementGet(_a, 1), b = traceur.runtime.elementGet(_b, 1);
    if (a.length != b.length) return b.length - a.length;
    var len = Math.max(a.length, b.length), extraA = 0, extraB = 0;
    for (var i = 0; i < len; i++) {
      if (traceur.runtime.elementGet(a, i) < 2 && traceur.runtime.elementGet(b, i) < 2 && traceur.runtime.elementGet(a, i) != traceur.runtime.elementGet(b, i)) return traceur.runtime.elementGet(a, i) - traceur.runtime.elementGet(b, i);
      var ak = traceur.runtime.elementGet(a, i) <= 2, bk = traceur.runtime.elementGet(b, i) <= 2;
      if (ak && !bk) extraA++;
      if (!ak && bk) extraB++;
    }
    if (extraA && !extraB) return - 1;
    if (!extraA && extraB) return 1;
    if (extraA && extraB) console.error('Can\'t sort ' + traceur.runtime.elementGet(_a, 0).$ct + ' ' + traceur.runtime.elementGet(_b, 0).$ct);
    return traceur.runtime.elementGet(_a, 0).$ct - traceur.runtime.elementGet(_b, 0).$ct;
  }));
  var code = '';
  mapKeys.forEach((function(k) {
    var v = traceur.runtime.elementGet(k, 0), ct = v.$ct, cond = '';
    var cstart = 0, cend = 0;
    var cmask = ct.replace(/^[^01]+/, (function(s) {
      cstart += s.length;
      return '';
    })).replace(/[^01]+$/, (function(s) {
      cend += s.length;
      return '';
    }));
    if (cmask.length) {
      cmask = Var(' ', cend, ct.length - cend - cstart, self.bigEndian).codeGen() + ' & 0x' + parseInt(cmask.replace(/0/g, '1').replace(/[^1]/g, '0'), 2).toString(16);
      console.log(ct.slice(cstart, ct.length - cend).replace(/[^01]/g, '0'));
      var cval = '0x' + parseInt(ct.slice(cstart, ct.length - cend).replace(/[^01]/g, '0'), 2).toString(16);
      cond = 'if((' + cmask + ') == ' + cval + ')';
    }
    cstart = cend = 0;
    var mask = ct.replace(/^[^K]+/, (function(s) {
      cstart += s.length;
      return '';
    })).replace(/[^K]+$/, (function(s) {
      cend += s.length;
      return '';
    }));
    mask = parseInt(mask.replace(/[^K]/g, '0').replace(/K/g, '1'), 2);
    var val = mask ? Var(' ', cend, ct.length - cend - cstart, self.bigEndian).codeGen() + ' & 0x' + mask.toString(16): '0';
    code += cond + '\n\tswitch(' + val + ') {\n';
    console.log('  \'' + ct.replace(/K/g, '#').replace(/x/g, '_') + '\': {');
    for (var j in v) if (j !== '$ct') {
      console.log('    \'' + j + '\': ', traceur.runtime.elementGet(v, j));
      val = '0x' + (parseInt(j.slice(cstart, ct.length - cend).replace(/[^01]/g, '0'), 2) & mask).toString(16);
      code += '\tcase ' + val + ': return [' + ct.length / 8 + ', ' + traceur.runtime.elementGet(v, j).map((function(x) {
        return codeGen(x);
      })).join(',') + '];\n';
    }
    console.log('  }');
    code += '\t}\n';
  }));
  console.log('}');
  console.log();
  fs.writeFileSync(outFile, fn(code));
};
