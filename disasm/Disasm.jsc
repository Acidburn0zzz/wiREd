!global.traceur && (0,eval)(require('fs').readFileSync(__dirname+'/../deps/traceur-compiler/bin/traceur.js', 'utf8'));
var $__0 = Object.freeze(Object.defineProperties(["if(known(a) && !known(b)) return ", "(b, a);"], {raw: {value: Object.freeze(["if(known(a) && !known(b)) return ", "(b, a);"])}})), $__1 = Object.freeze(Object.defineProperties(["if(a == 0) return b;"], {raw: {value: Object.freeze(["if(a == 0) return b;"])}})), $__2 = Object.freeze(Object.defineProperties(["if(b == 0) return a;"], {raw: {value: Object.freeze(["if(b == 0) return a;"])}})), $__3 = Object.freeze(Object.defineProperties(["if(a === b) return 0;"], {raw: {value: Object.freeze(["if(a === b) return 0;"])}})), $__4 = Object.freeze(Object.defineProperties(["if(a === b) return a;"], {raw: {value: Object.freeze(["if(a === b) return a;"])}})), $__5 = Object.freeze(Object.defineProperties(["if(known(a) && known(b)) return +(a ", " b);"], {raw: {value: Object.freeze(["if(known(a) && known(b)) return +(a ", " b);"])}})), $__6 = Object.freeze(Object.defineProperties(["if(b == -1 || !known(a) && a.bitsof && b == Math.pow(2, a.bitsof)-1) return ", ";"], {raw: {value: Object.freeze(["if(b == -1 || !known(a) && a.bitsof && b == Math.pow(2, a.bitsof)-1) return ", ";"])}})), $__7 = Object.freeze(Object.defineProperties(["if(a.op == '+' && known(a.b) && known(b)) return Add(a.a, a.b+b);"], {raw: {value: Object.freeze(["if(a.op == '+' && known(a.b) && known(b)) return Add(a.a, a.b+b);"])}})), $__8 = Object.freeze(Object.defineProperties(["if(a.op == '-' && a.a == b || b.op == '-' && b.a == a) return 0;"], {raw: {value: Object.freeze(["if(a.op == '-' && a.a == b || b.op == '-' && b.a == a) return 0;"])}}));
var fs = require('fs'), util = require('util');
function inspect(x, p) {
  if (known(x) && x >= 100) return '0x' + x.toString(16);
  if (typeof x === 'object' && x.inspect) return x.inspect(0, p || 16);
  return util.inspect(x);
}
function known(x) {
  return typeof x === 'number';
}
Object.defineProperties(Number.prototype, {
  known: {value: true},
  runtimeKnown: {value: true},
  code: {get: function() {
      if (this >= 100) return '0x' + this.toString(16);
      return this.toString();
    }}
});
function bitsof(x, fatal) {
  if (typeof x === 'object' && known(x.bitsof)) return x.bitsof;
  if (fatal) throw new TypeError('Missing bit size for ' + inspect(x)); else console.error('Missing bit size for ' + inspect(x));
}
function sizeof(x, fatal) {
  if (known(x = bitsof(x, fatal))) return Math.ceil(x / 8);
}
var codeGen = exports.codeGen = {intBits: 32};
codeGen.runtime = ["var util = require('util');", "var known = exports.known = function known(x) {\n    return typeof x === 'number';\n}", "var bitsof = exports.bitsof = function bitsof(x) {\n    if(typeof x === 'object' && 'bitsof' in x)\n        return x.bitsof;\n    throw new TypeError('Missing bit size for '+inspect(x));\n}", "var sizeof = exports.sizeof = function sizeof(x) {\n    return Math.ceil(bitsof(x)/8);\n}", "var valueof = exports.valueof = function valueof(x) {\n    if(known(x))\n        return x;\n    var v = x.value;\n    if(v === null || v === void 0)\n        return x;\n    return v;\n}", "var lvalueof = exports.lvalueof = function lvalueof(x) {\n    if(typeof x !== 'object' || !('lvalue' in x))\n        return valueof(x);\n    var v = x.lvalue;\n    if(v === null || v === void 0)\n        return x;\n    return v;\n}", "var inspect = exports.inspect = function inspect(x, p) {\n    if(known(x) && x >= 100)\n        return '0x'+x.toString(16);\n    if(typeof x === 'object' && x.inspect)\n        return x.inspect(0, p || 16);\n    return util.inspect(x);\n}"];
{
  try {
    throw undefined;
  } catch (fn) {
    fn = {};
    codeGen.int = (function(bits, signed) {
      var id = (signed ? 'i': 'u') + bits;
      if (!traceur.runtime.elementGet(fn, id)) {
        traceur.runtime.elementSet(fn, id, true);
        codeGen.runtime.push(("function " + id + "(x) {\n    if(known(x))\n        return " + (signed ? (bits == codeGen.intBits ? '(x&~0)': '((x<<' + (codeGen.intBits - bits) + ')>>' + (codeGen.intBits - bits) + ')'): (bits == codeGen.intBits ? '((x = x&~0), (x = x < 0 ? x+0x100000000 : x))': '(x&0x' + ((1 << bits) - 1).toString(16) + ')')) + ";\n    if(x.bitsof === " + bits + " && x.signed === " + signed + ")\n        return x;\n    if(x.hasOwnProperty('fn') && x.fn == 'Mem')" + (signed ? '': ' {') + "\n        x.bitsof = " + bits + ";" + (signed ? '': ("\n        return Object.create(x, {\n            value: {get: function() {\n                var v = valueof(x);\n                if(v !== x)\n                    return v.fn == 'Mem' ? " + id + "(v) : v;\n            }, set: function(v) {\n                x.value = v;\n            }},\n            lvalue: {get: function() {\n                var v = lvalueof(x);\n                if(v !== x)\n                    return v.fn == 'Mem' ? " + id + "(v) : v;\n            }},\n        });\n    }")) + "\n    return Object.create(x, {\n        bitsof: {value: " + bits + "},\n        signed: {value: " + signed + "},\n        value: {get: function() {\n            var v = valueof(x);\n            if(v !== x)\n                return " + id + "(v);\n        }, set: function(v) {\n            x.value = v;\n        }},\n        lvalue: {get: function() {\n            if(x.fn != 'Mem')\n                return;\n            var v = lvalueof(x);\n            if(v !== x)\n                return " + id + "(v);\n        }},\n        inspect: {value: function(_, p) {\n            var wrap = ('bitsof' in x) && x.bitsof != " + bits + ";\n            var ix = x.inspect ? x.inspect.call(this, _, !wrap && p || 16) : inspect(x, !wrap && p);\n            return wrap ? '" + id + "('+ix+')' : ix;\n        }}\n    });\n}"));
      }
      return id;
    });
  }
}
codeGen.runtime.vars = codeGen.runtime.maxVars = 0;
codeGen.getVar = (function() {
  var name = '$' + (codeGen.runtime.vars++);
  if (codeGen.runtime.vars > codeGen.runtime.maxVars) codeGen.runtime.maxVars = codeGen.runtime.vars;
  return name;
});
codeGen.mark = (function(a, props) {
  var refCount = 0, varName;
  if (a.hasOwnProperty('args')) a.args.forEach((function(x) {
    return x.touch && x.touch();
  })); else if (a.hasOwnProperty('a')) {
    a.a.touch && a.a.touch();
    if (a.hasOwnProperty('b')) a.b.touch && a.b.touch();
  } else if (a.touch) a.touch();
  a.touch = (function() {
    return (refCount++, null);
  });
  if (props) a = Object.create(a, props);
  return Object.create(a, {code: {get: (function() {
        if (refCount <= 1) return a.code;
        if (!varName) {
          varName = codeGen.getVar();
          return '(' + varName + ' = ' + a.code + ')';
        }
        return varName;
      })}});
});
codeGen.normalize = (function(a) {
  if (typeof a.bitsof !== 'number' || typeof a.signed !== 'boolean') return codeGen.mark(a);
  var bits = bitsof(a, true), props = {};
  if (a.runtimeKnown) {
    if (a.signed) {
      if (bits == codeGen.intBits) props.code = {get: (function() {
          return '(' + a.code + '&~0)';
        })}; else props.code = {get: (function() {
          return '((' + a.code + '<<' + (codeGen.intBits - bits) + ')>>' + (codeGen.intBits - bits) + ')';
        })};
    } else {
      if (bits == codeGen.intBits) {
        var temp = codeGen.getVar();
        props.code = {get: (function() {
            return ("((" + temp + " = " + a.code + "&~0), (" + temp + " < 0 ? " + temp + "+0x100000000 : " + temp + "))");
          })};
      } else props.code = {get: (function() {
          return '(' + a.code + '&0x' + ((1 << bits) - 1).toString(16) + ')';
        })};
    }
  } else props.code = {get: (function() {
      return codeGen.int(bits, a.signed) + '(' + a.code + ')';
    })};
  props.inspect = {value: (function(_, p) {
      return codeGen.int(bits, a.signed) + '(' + inspect(a, p) + ')';
    })};
  return codeGen.mark(a, props);
});
var exportedFn = {
  inspect: inspect,
  known: known,
  bitsof: bitsof,
  sizeof: sizeof,
  Sub: (function(a, b) {
    if (a == b) return 0;
    return Add(a, Neg(b));
  }),
  ROL: (function(a, b) {
    var bitsa = traceur.runtime.elementGet(arguments, 2) !== (void 0) ? traceur.runtime.elementGet(arguments, 2): bitsof(a, true);
    return Or(LSL(a, b), LSR(a, Sub(bitsa, b)));
  }),
  ROR: (function(a, b) {
    var bitsa = traceur.runtime.elementGet(arguments, 2) !== (void 0) ? traceur.runtime.elementGet(arguments, 2): bitsof(a, true);
    return Or(LSR(a, b), LSL(a, Sub(bitsa, b)));
  }),
  IntSize: function(a, bits) {
    if (bitsof(a) == bits) return a;
    a = Object.create(a);
    a.bitsof = bits;
    if (!(traceur.runtime.elementHas(a, 'signed'))) a.signed = false;
    return codeGen.normalize(a);
  },
  IntSigned: function(a, signed) {
    if (a.signed === signed) return a;
    a = Object.create(a);
    a.signed = signed;
    return codeGen.normalize(a);
  },
  IntSizeSigned: function(a, bits, signed) {
    if (bitsof(a) == bits && a.signed === signed) return a;
    a = Object.create(a);
    a.bitsof = bits;
    a.signed = signed;
    return codeGen.normalize(a);
  },
  signed: (function(a) {
    return IntSigned(a, true);
  }),
  unsigned: (function(a) {
    return IntSigned(a, false);
  })
};
{
  var $__10 = traceur.runtime.getIterator([[true, 'i'], [false, 'u']]);
  try {
    while ($__10.moveNext()) {
      try {
        throw undefined;
      } catch (pfx) {
        try {
          throw undefined;
        } catch (signed) {
          try {
            throw undefined;
          } catch ($__12) {
            {
              $__12 = $__10.current;
              signed = traceur.runtime.elementGet($__12, 0);
              pfx = traceur.runtime.elementGet($__12, 1);
            }
            {
              var $__9 = traceur.runtime.getIterator([8, 16, 32]);
              try {
                while ($__9.moveNext()) {
                  try {
                    throw undefined;
                  } catch (bits) {
                    bits = $__9.current;
                    traceur.runtime.elementSet(exportedFn, pfx + bits, (function(a) {
                      return IntSizeSigned(a, bits, signed);
                    }));
                  }
                }
              } finally {
                if ($__9.close) $__9.close();
              }
            }
          }
        }
      }
    }
  } finally {
    if ($__10.close) $__10.close();
  }
}
var precendence = {
  '()': 1,
  '[]': 1,
  '~': 2,
  '*': 3,
  '/': 3,
  '%': 3,
  '+': 4,
  '-': 4,
  '<<': 5,
  '>>': 5,
  '>>>': 5,
  '<': 6,
  '==': 7,
  '&': 8,
  '^': 9,
  '|': 10,
  '=': 13,
  '<->': 13,
  ',': 14
};
'Nop,Interrupt'.split(',').forEach(function(fn) {
  traceur.runtime.elementSet(exportedFn, fn, (function() {
    for (var args = [], $__11 = 0; $__11 < arguments.length; $__11++) traceur.runtime.elementSet(args, $__11, traceur.runtime.elementGet(arguments, $__11));
    return codeGen.mark({
      inspect: (function() {
        return fn + '(' + args.map((function(x) {
          return inspect(x);
        })).join(', ') + ')';
      }),
      get code() {
        return fn + '(' + args.map((function(x) {
          return x.code;
        })).join(', ') + ')';
      },
      runtimeKnown: false
    });
  }));
  codeGen.runtime.push(("function " + fn + "() {\n    var args = [].slice.call(arguments);\n    return {\n        constructor: " + fn + ", fn: '" + fn + "', args: args,\n        get value() {\n            var changes = false, v = args.map(function(x) {\n                var v = valueof(x);\n                if(v !== x)\n                    changes = true;\n                return v;\n            });\n            if(changes) return " + fn + ".apply(null, v);\n        },\n        inspect: function() {\n            return '" + fn + "('+args.map(function(x) {return inspect(x);}).join(', ')+')';\n        }\n    };\n}"));
});
exportedFn.If = (function(cond, then) {
  if (arguments.length != 2) throw new RangeError('Wrong number of arguments to If');
  return codeGen.mark({
    fn: 'If',
    args: [cond, then],
    cond: cond,
    then: then,
    inspect: function() {
      return 'if(' + inspect(cond) + ') ' + inspect(then) + ';';
    },
    get code() {
      return 'If(' + cond.code + ', ' + then.code + ')';
    },
    runtimeKnown: false
  });
});
codeGen.runtime.push("var If = exports.If = function If(cond, then) {\n    if(known(cond)) return cond ? then : Nop();\n    return {\n        constructor: If, fn: 'If', cond: cond, then: then,\n        get value() {\n            var vcond = valueof(cond);\n            if(vcond !== cond) {\n                if(known(vcond)) return cond ? valueof(then) : Nop();\n                return If(vcond, then);\n            }\n        },\n        inspect: function() {\n            return 'if('+inspect(cond)+') '+inspect(then)+';';\n        }\n    };\n};\n");
exportedFn.Mem = (function(a) {
  var size = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): null;
  if (size !== null) throw new Error('Deprecated size argument for Mem');
  return codeGen.mark({
    fn: 'Mem',
    a: a,
    inspect: function() {
      return '[' + inspect(a) + ']' + (this.bitsof || '');
    },
    get code() {
      return 'Mem(' + a.code + ')';
    },
    runtimeKnown: false
  });
});
codeGen.runtime.push("var Mem = exports.Mem = function Mem(a) {\n    return {\n        constructor: Mem, fn: 'Mem', a: a,\n        get lvalue() {\n            var v = valueof(a);\n            if(v !== a) return Mem(v);\n        },\n        get value() {\n            var v = valueof(a), m = Mem.read(v, bitsof(this));\n            if(m !== null && m !== void 0)\n                return m;\n            if(v !== a) return Mem(v);\n        },\n        set value(v) {\n            return Mem.write(valueof(a), bitsof(this), v);\n        },\n        inspect: function() {\n            return '['+inspect(a)+']'+(this.bitsof || '');\n        }\n    };\n};\nMem.read = function(address, bits) {\n    console.error('Non-implemented Mem read ['+inspect(address)+']'+bits);\n};\nMem.write = function(address, bits, value) {\n    console.error('Non-implemented Mem write ['+inspect(address)+']'+bits+' = '+inspect(value));\n};\n");
exportedFn.Not = (function(a) {
  return known(a) ? ~a: codeGen.normalize({
    fn: 'Not',
    op: '~',
    a: a,
    bitsof: bitsof(a),
    signed: a.signed,
    inspect: (function() {
      return '~' + inspect(a, traceur.runtime.elementGet(precendence, '~'));
    }),
    get code() {
      return a.runtimeKnown ? '~' + a.code: 'Not(' + a.code + ')';
    },
    runtimeKnown: a.runtimeKnown
  });
});
codeGen.runtime.push(("function Not(a) {\n    if(known(a)) return ~a;\n    if(a.op == '~') return a.a;\n    return {\n        constructor: Not, fn: 'Not', op: '~', a: a,\n        get value() {\n            var v = valueof(a);\n            if(v !== a) return Not(v);\n        },\n        inspect: function(_, p) {\n            if(this.bitsof == 1 && a.op == '==') {\n                var expr = inspect(a.a, " + traceur.runtime.elementGet(precendence, '==') + ")+' != '+inspect(a.b, " + traceur.runtime.elementGet(precendence, '==') + ");\n                return " + traceur.runtime.elementGet(precendence, '==') + " <= p ? expr : '('+expr+')'\n            }\n            if(this.bitsof == 1 && a.op == '<') {\n                var expr = inspect(a.a, " + traceur.runtime.elementGet(precendence, '<') + ")+' >= '+inspect(a.b, " + traceur.runtime.elementGet(precendence, '<') + ");\n                return " + traceur.runtime.elementGet(precendence, '<') + " <= p ? expr : '('+expr+')'\n            }\n            var expr = '~'+inspect(a, " + traceur.runtime.elementGet(precendence, '~') + ");\n            return " + traceur.runtime.elementGet(precendence, '~') + " <= p ? expr : '('+expr+')';\n        }\n    };\n}"));
exportedFn.Neg = (function(a) {
  return known(a) ? - a: codeGen.normalize({
    fn: 'Neg',
    op: '-',
    a: a,
    bitsof: bitsof(a),
    signed: true,
    inspect: (function() {
      return '-' + inspect(a, traceur.runtime.elementGet(precendence, '~'));
    }),
    get code() {
      return a.runtimeKnown ? '-' + a.code: 'Neg(' + a.code + ')';
    },
    runtimeKnown: a.runtimeKnown,
    CF: Not(Eq(a, 0))
  });
});
codeGen.runtime.push(("function Neg(a) {\n    if(known(a)) return -a;\n    if(a.op == '-') return a.a;\n    return {\n        constructor: Neg, fn: 'Neg', op: '-', a: a,\n        get value() {\n            var v = valueof(a);\n            if(v !== a) return Neg(v);\n        },\n        inspect: function(_, p) {\n            var expr = '-'+inspect(a, " + traceur.runtime.elementGet(precendence, '~') + ");\n            return " + traceur.runtime.elementGet(precendence, '~') + " <= p ? expr : '('+expr+')';\n        }\n    };\n}"));
var binaryOps = {
  Mov: '=',
  Swap: '<->',
  Add: '+',
  Mul: '*',
  And: '&',
  Or: '|',
  Xor: '^',
  Eq: '==',
  Lt: '<',
  LSL: '<<',
  LSR: '>>>',
  ASR: '>>'
};
Object.keys(binaryOps).forEach(function(fn) {
  var op = traceur.runtime.elementGet(binaryOps, fn), prec = traceur.runtime.elementGet(precendence, op);
  var prologue = '', p = (function(s) {
    for (var args = [], $__11 = 1; $__11 < arguments.length; $__11++) traceur.runtime.elementSet(args, $__11 - 1, traceur.runtime.elementGet(arguments, $__11));
    return prologue += '\n    ' + s.map((function(x, i) {
      return i ? traceur.runtime.elementGet(args, i - 1) + x: x;
    })).join('');
  });
  if (op == '+' || op == '&' || op == '|' || op == '^') p($__0, fn);
  if (op == '+' || op == '|' || op == '^') p($__1);
  if (op == '+' || op == '|' || op == '^' || op == '<<' || op == '>>' || op == '>>>') p($__2);
  if (op == '^') p($__3);
  if (op == '&' || op == '|') p($__4);
  if (op != '=' && op != '<->') p($__5, op);
  if (op == '|' || op == '&') p($__6, (op == '|' ? 'b': 'a'));
  if (op == '+') p($__7);
  if (op == '+') p($__8);
  var prologueFn = eval(("(function(a, b) {" + prologue + "})"));
  traceur.runtime.elementSet(exportedFn, fn, function(a, b) {
    var o = prologueFn(a, b);
    if (typeof o !== 'undefined') return o;
    o = {
      fn: fn,
      op: op,
      a: a,
      b: b,
      inspect: function(_, p) {
        var op = this.op, a = this.a, b = this.b;
        if (op == '+' && b < 0) op = '-', b = - b;
        if (op == '=' && b.op && b.op != '=' && b.op != '<->' && b.op != '==' && b.op != '<' && b.a === a) {
          op = b.op + '=';
          b = b.b;
        }
        var expr = inspect(a, prec) + ' ' + op + ' ' + inspect(b, prec);
        return prec <= p ? expr: '(' + expr + ')';
      },
      get code() {
        return a.runtimeKnown && b.runtimeKnown ? '(' + a.code + ' ' + op + ' ' + b.code + ')': fn + '(' + a.code + ', ' + b.code + ')';
      },
      runtimeKnown: a.runtimeKnown && b.runtimeKnown,
      CF: 0,
      NF: 0,
      OF: 0
    };
    if (op == '==' || op == '<') o.bitsof = 1, o.signed = false; else {
      var bitsa = bitsof(a);
      if (op == '<<' || op == '>>' || op == '>>>') o.bitsof = bitsa, o.signed = a.signed; else if (op != '<->' && known(bitsa) && known(b)) o.bitsof = bitsa, o.signed = a.signed; else {
        var bitsb = bitsof(b);
        if (op != '=' && op != '<->' && known(bitsa) && known(bitsb)) {
          if (bitsa != bitsb) {
            console.error(fn + ' called with differently typed operands (' + (a.signed) + '/' + bitsa + ', ' + (b.signed) + '/' + bitsb + '): ' + inspect(a) + ', ' + inspect(b));
            if (bitsb > bitsa) bitsa = bitsb;
          }
          o.bitsof = bitsa;
          o.signed = a.signed !== b.signed ? false: a.signed;
        }
      }
    }
    if (op == '==' || op == '<' || op == '=' || op == '<->') return codeGen.mark(o);
    if (op == '+' && b.fn == 'Neg') {
      o.ZF = Eq(a, b.a);
      o.CF = Lt(a, b.a);
    } else {
      o.ZF = Eq(o, 0);
      o.NF = Lt(o, 0);
    }
    return codeGen.normalize(o);
  });
  codeGen.runtime.push(("var " + fn + " = exports." + fn + " = function " + fn + "(a, b) {" + prologue + "\n    return {\n        constructor: " + fn + ", fn: '" + fn + "', op: '" + op + "', a: a, b: b," + (op == '=' || op == '<' ? ' bitsof: 1,': '') + "\n        get value() {\n            var va = " + (op == '=' || op == '<->' ? 'lvalueof': 'valueof') + "(a), vb = " + (op == '<->' ? 'lvalueof': 'valueof') + "(b);\n            if(va !== a || vb !== b) return " + fn + "(va, vb);\n        },\n        inspect: function(_, p) {\n            var a = this.a, b = this.b;" + (op == '=' || op == '+' ? ("\n            var op = '" + op + "';\n            "): '') + (op == '+' ? "if(b < 0) {\n                op = '-';\n                b = -b;\n            } else if(b.op == '-') {\n                op = '-';\n                b = b.a;\n            }": '') + (op == '=' ? "if(b.op && b.op != '=' && b.op != '<->' && b.op != '==' && b.op != '<' && b.op != '-' && b.op != '~' && b.a === a) {\n                if(b.op == '+' && b.b < 0) {\n                    op = '-=';\n                    b = -b.b;\n                } else {\n                    op = b.op+'=';\n                    b = b.b;\n                }\n            }": '') + "var expr = inspect(a, " + prec + ")+' " + (op == '=' || op == '+' ? "'+op+'": op) + " '+inspect(b, " + prec + ");\n            return " + prec + " <= p ? expr : '('+expr+')';\n        }\n    };\n}"));
});
for (var i in exportedFn) traceur.runtime.elementSet(global, i, traceur.runtime.elementGet(exportedFn, i));
exports.filters = {};
function Var(name, pos, len, bigEndian) {
  return codeGen.mark({
    name: name,
    pos: pos,
    len: len,
    bitsof: len,
    signed: len == codeGen.intBits,
    posAt: function(d) {
      if (!(d >= 0 && d < this.len)) throw new RangeError('Offset ' + d + ' is outside the bit range');
      d += this.pos & 7;
      var pos = (this.pos & ~7) + (d & 7);
      if (bigEndian) return pos - (d & ~7);
      return pos + (d & ~7);
    },
    inspect: function() {
      return '<' + this.pos + (this.len > 1 ? ':' + (this.pos + this.len - 1): '') + '>';
    },
    get code() {
      if (this.len > codeGen.intBits) throw new RangeError('Too many (' + this.len + ') bits to decode');
      var bytes = [];
      var pos = this.pos & ~7, bits = this.pos & 7;
      var end = this.pos + this.len, endBits = end & 7;
      if (bits) {
        bytes.push('((b[i+' + (pos >>> 3) + '] & 0x' + (((1 << Math.min(this.len, 8 - bits)) - 1) << bits).toString(16) + ')>>>' + bits + ')');
        pos += 8;
      }
      for (var j = pos >>> 3; pos + 8 <= end; pos += 8, j += (bigEndian ? - 1: 1)) bytes.push(pos > this.pos ? '(b[i+' + j + ']<<' + (pos - this.pos) + ')': 'b[i+' + j + ']');
      if (pos < end) bytes.push(pos > this.pos ? '((b[i+' + j + '] & 0x' + ((1 << endBits) - 1).toString(16) + ')<<' + (pos - this.pos) + ')': '(b[i+' + j + '] & 0x' + ((1 << endBits) - 1).toString(16) + ')');
      return '(' + bytes.join('|') + ')';
    },
    runtimeKnown: true,
    slice: function(name, start, end) {
      if (typeof start !== 'number') start = 0; else if (start < 0) start += this.len;
      if (typeof end !== 'number') end = this.len; else if (end < 0) end += this.len;
      return Var(name, this.posAt(start), end - start, bigEndian);
    },
    filter: traceur.runtime.elementGet(exports.filters, name) || traceur.runtime.elementGet(exports.filters, name[0]) || function(next, ct) {
      if (this.len === 1) return next(traceur.runtime.elementSet(ct, this.pos, 0)), next(traceur.runtime.elementSet(ct, this.pos, 1));
      next(this);
    }
  });
}
exports.totals = 0;
exports.maps = {};
exports.op = function op(def, fn) {
  var self = this;
  var ct = [], vars = [], nBits = 0;
  def.forEach(function(x) {
    var n = x.length, bits = x.match(/[A-Z][a-z$]*_*|./g);
    if (n & 7) throw new TypeError('Opcode definition ' + x + ' does not align to a byte boundary');
    var part = Var(' ', nBits + (self.bigEndian ? n - 8: 0), n, self.bigEndian);
    for (var i = 0, j = n; i < bits.length && j > 0; i++) {
      var b = traceur.runtime.elementGet(bits, i);
      if (b === '0' || b === '1') traceur.runtime.elementSet(ct, part.posAt(j - 1), + b); else vars.push(part.slice(b.replace(/_+/g, ''), j - b.length, j));
      j -= b.length;
    }
    nBits += n;
  });
  function make(ct, vals) {
    var res = fn.apply(this, vals);
    if (!res) return;
    res = res.filter((function(x) {
      return x;
    }));
    res.forEach((function(x) {
      return x.touch && x.touch();
    }));
    function niceCT(ct) {
      var s = '';
      for (var i = nBits - 1; i >= 0; i--) s += typeof traceur.runtime.elementGet(ct, i) === 'number' ? traceur.runtime.elementGet(ct, i): 'x';
      return s;
    }
    ct = niceCT(ct);
    var ctMask = ct.replace(/[01]/g, 'K');
    self.totals += 100 / Math.pow(2, ctMask.split('').reduce((function(a, b) {
      return a + (b == 'K');
    }), 0));
    if (!traceur.runtime.elementGet(self.maps, ctMask)) traceur.runtime.elementSet(self.maps, ctMask, {$ct: ct}); else traceur.runtime.elementGet(self.maps, ctMask).$ct = traceur.runtime.elementGet(self.maps, ctMask).$ct.split('').map((function(x, i) {
      return x == traceur.runtime.elementGet(ct, i) ? x: 'K';
    })).join('');
    traceur.runtime.elementSet(traceur.runtime.elementGet(self.maps, ctMask), ct, res);
    console.log.apply(console, [ct + ':'].concat(res));
  }
  var vals = [];
  vals.byName = {};
  var back = (function(i, ct) {
    ct = ct.slice();
    if (i >= vars.length) return make(ct, vals);
    var v = traceur.runtime.elementGet(vars, i), name = v.name;
    Var(name, v.pos, v.len, this.bigEndian).filter((function(v, ct2) {
      traceur.runtime.elementSet(vals, i, traceur.runtime.elementSet(vals.byName, name, v));
      back(i + 1, ct2 || ct);
    }), ct, i, vals);
  }).bind(this);
  back(0, ct);
  console.log();
};
exports.out = function out(outFile, fn) {
  console.error('Totals:', Math.round(this.totals * 100) / 100 + '%');
  console.log('{');
  var self = this;
  var mapKeys = Object.keys(self.maps).map((function(x) {
    return [traceur.runtime.elementGet(self.maps, x), traceur.runtime.elementGet(self.maps, x).$ct.split('').map((function(x) {
      return traceur.runtime.elementGet(({
        '0': 0,
        '1': 1,
        K: 2
      }), x);
    }))];
  }));
  mapKeys.sort((function(_a, _b) {
    var a = traceur.runtime.elementGet(_a, 1), b = traceur.runtime.elementGet(_b, 1);
    if (a.length != b.length) return b.length - a.length;
    var len = Math.max(a.length, b.length), extraA = 0, extraB = 0;
    for (var i = 0; i < len; i++) {
      if (traceur.runtime.elementGet(a, i) < 2 && traceur.runtime.elementGet(b, i) < 2 && traceur.runtime.elementGet(a, i) != traceur.runtime.elementGet(b, i)) return traceur.runtime.elementGet(a, i) - traceur.runtime.elementGet(b, i);
      var ak = traceur.runtime.elementGet(a, i) <= 2, bk = traceur.runtime.elementGet(b, i) <= 2;
      if (ak && !bk) extraA++;
      if (!ak && bk) extraB++;
    }
    if (extraA && !extraB) return - 1;
    if (!extraA && extraB) return 1;
    if (extraA && extraB) console.error('Can\'t sort ' + traceur.runtime.elementGet(_a, 0).$ct + ' ' + traceur.runtime.elementGet(_b, 0).$ct);
    return traceur.runtime.elementGet(_a, 0).$ct - traceur.runtime.elementGet(_b, 0).$ct;
  }));
  var code = '';
  mapKeys.forEach((function(k) {
    var v = traceur.runtime.elementGet(k, 0), ct = v.$ct, cond = '';
    var cstart = 0, cend = 0;
    var cmask = ct.replace(/^[^01]+/, (function(s) {
      cstart += s.length;
      return '';
    })).replace(/[^01]+$/, (function(s) {
      cend += s.length;
      return '';
    }));
    if (cmask.length) {
      cmask = Var(' ', cend, ct.length - cend - cstart).code + ' & 0x' + parseInt(cmask.replace(/0/g, '1').replace(/[^1]/g, '0'), 2).toString(16);
      console.log(ct.slice(cstart, ct.length - cend).replace(/[^01]/g, '0'));
      var cval = '0x' + parseInt(ct.slice(cstart, ct.length - cend).replace(/[^01]/g, '0'), 2).toString(16);
      cond = 'if((' + cmask + ') == ' + cval + ')';
    }
    cstart = cend = 0;
    var mask = ct.replace(/^[^K]+/, (function(s) {
      cstart += s.length;
      return '';
    })).replace(/[^K]+$/, (function(s) {
      cend += s.length;
      return '';
    }));
    mask = parseInt(mask.replace(/[^K]/g, '0').replace(/K/g, '1'), 2);
    var val = mask ? Var(' ', cend, ct.length - cend - cstart).code + ' & 0x' + mask.toString(16): '0';
    code += cond + '\n\tswitch(' + val + ') {\n';
    console.log('  \'' + ct.replace(/K/g, '#').replace(/x/g, '_') + '\': {');
    for (var j in v) if (j !== '$ct') {
      console.log('    \'' + j + '\': ', traceur.runtime.elementGet(v, j));
      val = '0x' + (parseInt(j.slice(cstart, ct.length - cend).replace(/[^01]/g, '0'), 2) & mask).toString(16);
      codeGen.runtime.vars = 0;
      code += '\tcase ' + val + ': return [' + ct.length / 8 + ', ' + traceur.runtime.elementGet(v, j).map((function(x) {
        return x.code;
      })).join(',') + '];\n';
      codeGen.runtime.vars = 0;
    }
    console.log('  }');
    code += '\t}\n';
  }));
  if (codeGen.runtime.maxVars) {
    try {
      throw undefined;
    } catch (s) {
      s = '\n\tvar $0';
      for (var i = 1; i < codeGen.runtime.maxVars; i++) s += ', $' + i;
      code = s + ';\n' + code;
    }
  }
  console.log('}\n');
  fs.writeFileSync(outFile, fn(code));
};

//@ sourceMappingURL=Disasm.map