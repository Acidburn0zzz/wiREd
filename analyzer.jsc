!global.traceur && (0,eval)(require('fs').readFileSync(__dirname+'/deps/traceur-compiler/bin/traceur.js', 'utf8'));
var $__superDescriptor = function(proto, name) {
  if (!proto) throw new TypeError('super is null');
  return Object.getPropertyDescriptor(proto, name);
}, $__superCall = function(self, proto, name, args) {
  var descriptor = $__superDescriptor(proto, name);
  if (descriptor) {
    if (traceur.runtime.elementHas(descriptor, 'value')) return descriptor.value.apply(self, args);
    if (descriptor.get) return descriptor.get.call(self).apply(self, args);
  }
  throw new TypeError("Object has no method '" + name + "'.");
}, $__getProtoParent = function(superClass) {
  if (typeof superClass === 'function') return superClass.prototype;
  if (superClass === null) return null;
  if (Object(superClass) === superClass) return superClass;
  throw new TypeError();
}, $__createClass = function(object, protoParent, superClass, hasConstructor) {
  var ctor = object.constructor;
  if (typeof superClass === 'function') {
    if (protoParent === null) throw new TypeError();
    ctor.__proto__ = superClass;
  } else if (superClass === null && !hasConstructor) {
    ctor = object.constructor = function() {};
  }
  var descriptors = {}, name, names = Object.getOwnPropertyNames(object);
  for (var i = 0; i < names.length; i++) {
    var name = traceur.runtime.elementGet(names, i);
    traceur.runtime.elementSet(descriptors, name, Object.getOwnPropertyDescriptor(object, name));
  }
  descriptors.constructor.enumerable = false;
  ctor.prototype = Object.create(protoParent, descriptors);
  return ctor;
}, $__toObject = function(value) {
  if (value == null) throw TypeError();
  return Object(value);
};
String.prototype.padLeft = function padLeft(n, p) {
  p = p || ' ';
  var s = this.toString();
  while (s.length < n) s = p + s;
  return s;
};
String.prototype.padRight = function padRight(n, p) {
  p = p || ' ';
  var s = this.toString();
  while (s.length < n) s += p;
  return s;
};
Number.prototype.toSubString = function toSubString() {
  var $__9;
  for (var args = [], $__2 = 0; $__2 < arguments.length; $__2++) traceur.runtime.elementSet(args, $__2, traceur.runtime.elementGet(arguments, $__2));
  return ($__9 = this).toString.apply($__9, $__toObject(args)).replace(/[0-9]/g, function(x) {
    return String.fromCharCode('₀'.charCodeAt() + (+ x));
  });
};
Number.prototype.toSupString = function toSupString() {
  var $__9;
  for (var args = [], $__3 = 0; $__3 < arguments.length; $__3++) traceur.runtime.elementSet(args, $__3, traceur.runtime.elementGet(arguments, $__3));
  return ($__9 = this).toString.apply($__9, $__toObject(args)).replace(/1/g, '¹').replace(/2/g, '²').replace(/3/g, '³').replace(/x/g, 'ˣ').replace(/[0-9]/g, function(x) {
    return String.fromCharCode('⁰'.charCodeAt() + (+ x));
  }).replace(/[a-z]/g, function(x) {
    return traceur.runtime.elementGet('ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖqʳˢᵗᵘᵛʷˣʸᶻ', x.charCodeAt() - 'a'.charCodeAt());
  });
};
{
  try {
    throw undefined;
  } catch (indent) {
    try {
      throw undefined;
    } catch (oldFormat) {
      try {
        throw undefined;
      } catch (util) {
        {
          util = require('util');
          oldFormat = util.format;
          indent = '';
        }
        util.format = function() {
          for (var args = [], $__4 = 0; $__4 < arguments.length; $__4++) traceur.runtime.elementSet(args, $__4, traceur.runtime.elementGet(arguments, $__4));
          return oldFormat.apply(this, args).replace(/(?:^|\n)/g, '$&' + indent);
        };
        console.group = (function(name) {
          console.log(name, '{');
          indent += '    ';
        });
        console.groupEnd = (function() {
          if (indent == '') return false;
          indent = indent.slice(0, - 4);
          console.log('}');
        });
      }
    }
  }
}
var makeAnalyzer = (function(arch) {
  var EventEmitter = require('events').EventEmitter;
  var $__5 = arch, R = $__5.R, PC = $__5.PC, SP = $__5.SP, Add = $__5.Add, Mov = $__5.Mov, Mem = $__5.Mem, known = $__5.known, valueof = $__5.valueof, lvalueof = $__5.lvalueof, sizeof = $__5.sizeof, inspect = $__5.inspect, analyzer;
  var AnalysisPauseError = function($__super) {
    var $__proto = $__getProtoParent($__super);
    var $AnalysisPauseError = ($__createClass)({constructor: function() {
        var reason = traceur.runtime.elementGet(arguments, 0) !== (void 0) ? traceur.runtime.elementGet(arguments, 0): '';
        $__superCall(this, $__proto, "constructor", ['Analysis paused: ' + reason]);
      }}, $__proto, $__super, true);
    return $AnalysisPauseError;
  }(Error);
  var Block = function($__super) {
    var $__proto = $__getProtoParent($__super);
    var $Block = ($__createClass)({
      constructor: function() {
        var options = traceur.runtime.elementGet(arguments, 0) !== (void 0) ? traceur.runtime.elementGet(arguments, 0): {};
        $__superCall(this, $__proto, "constructor", []);
        this.stack = [{
          down: [],
          up: []
        }];
        this.stackMaxAccess = - Infinity;
        this.returnPoints = [];
        this.on('returnPoint', (function(x) {
          if (traceur.runtime.is(this.returnPoints.indexOf(x), - 1)) this.returnPoints.push(x);
        }).bind(this));
        this.R = {};
        this.R0 = {};
        for (var $i in R) {
          try {
            throw undefined;
          } catch (i) {
            i = $i;
            traceur.runtime.elementSet(this.R0, i, {
              bitsof: traceur.runtime.elementGet(R, i).bitsof,
              signed: traceur.runtime.elementGet(R, i).signed,
              inspect: (function() {
                return inspect(traceur.runtime.elementGet(R, i)) + '₀';
              })
            });
            traceur.runtime.elementSet(this.R, i, {
              nthValue: 1,
              value: traceur.runtime.elementGet(this.R0, i)
            });
            if (traceur.runtime.elementGet(R, i) == SP) {
              this.SP0 = [traceur.runtime.elementGet(this.R0, i)];
              this.SP = traceur.runtime.elementGet(this.R, i);
            }
          }
        }
        this.retPC = {inspect: (function() {
            return 'ret' + inspect(PC);
          })};
        for (var $i in options) {
          try {
            throw undefined;
          } catch (i) {
            i = $i;
            traceur.runtime.elementSet(this, i, traceur.runtime.elementGet(options, i));
          }
        }
      },
      saveContext: function() {
        for (var $i in R) {
          try {
            throw undefined;
          } catch (i) {
            i = $i;
            traceur.runtime.elementSet(this.R, i, {
              nthValue: traceur.runtime.elementGet(R, i).nthValue,
              value: traceur.runtime.elementGet(R, i).value
            });
            if (traceur.runtime.elementGet(R, i) == SP) this.SP = traceur.runtime.elementGet(this.R, i);
          }
        }
        analyzer.memRead = analyzer.memWrite = null;
      },
      SPdiff: function(SP) {
        var SP0 = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): traceur.runtime.elementGet(this.SP0, this.SP0.length - 1);
        if (SP == SP0) return 0;
        if (SP.op == '+' && SP.a == SP0 && known(SP.b)) return SP.b;
        return NaN;
      },
      SPdiffAll: function(SP) {
        {
          try {
            throw undefined;
          } catch ($i) {
            $i = this.SP0.length - 1;
            for (; $i >= 0; $i--) {
              try {
                throw undefined;
              } catch (i) {
                i = $i;
                try {
                  try {
                    throw undefined;
                  } catch (diff) {
                    diff = this.SPdiff(SP, traceur.runtime.elementGet(this.SP0, i));
                    if (traceur.runtime.isnt(diff, NaN)) return [i, diff];
                  }
                } finally {
                  $i = i;
                }
              }
            }
          }
        }
        return [- 1, NaN];
      },
      readStack: function(pos, bits) {
        var stack = traceur.runtime.elementGet(arguments, 2) !== (void 0) ? traceur.runtime.elementGet(arguments, 2): traceur.runtime.elementGet(this.stack, this.stack.length - 1);
        var bytes = traceur.runtime.elementGet(arguments, 3) !== (void 0) ? traceur.runtime.elementGet(arguments, 3): bits / 8;
        if (stack == traceur.runtime.elementGet(this.stack, 0)) this.stackMaxAccess = Math.max(this.stackMaxAccess, pos + bytes);
        if (pos < 0) {
          pos = ~pos;
          stack = stack.down;
        } else stack = stack.up;
        var v = traceur.runtime.elementGet(stack, pos);
        if (!v) return;
        if (v.invalid) throw new Error('Reading invalid stack value ' + inspect(v));
        if (v.bitsof != bits) throw new Error('Reading differently sized stack value ' + inspect(v));
        return v.value;
      },
      writeStack: function(pos, bits, v) {
        var stack = traceur.runtime.elementGet(arguments, 3) !== (void 0) ? traceur.runtime.elementGet(arguments, 3): traceur.runtime.elementGet(this.stack, this.stack.length - 1);
        var bytes = traceur.runtime.elementGet(arguments, 4) !== (void 0) ? traceur.runtime.elementGet(arguments, 4): bits / 8;
        var canBeArg = false;
        if (stack == traceur.runtime.elementGet(this.stack, this.stack.length - 1) && pos == this.SPdiff(valueof(SP))) canBeArg = true;
        var originalPos = pos;
        if (pos < 0) {
          pos = ~pos;
          stack = stack.down;
        } else stack = stack.up;
        traceur.runtime.elementSet(stack, pos, {
          bitsof: bits,
          canBeArg: canBeArg,
          value: v,
          parent: this,
          PC: this.PC,
          PCnext: this.PCnext
        });
        if (originalPos < 0) {
          try {
            throw undefined;
          } catch ($i) {
            $i = pos - 1;
            for (; $i > pos - bytes; $i--) {
              try {
                throw undefined;
              } catch (i) {
                i = $i;
                try {
                  traceur.runtime.elementSet(stack, i, {
                    invalid: true,
                    parent: traceur.runtime.elementGet(stack, pos)
                  });
                } finally {
                  $i = i;
                }
              }
            }
          }
        } else {
          try {
            throw undefined;
          } catch ($i) {
            $i = pos + 1;
            for (; $i < pos + bytes; $i++) {
              try {
                throw undefined;
              } catch (i) {
                i = $i;
                try {
                  traceur.runtime.elementSet(stack, i, {
                    invalid: true,
                    parent: traceur.runtime.elementGet(stack, pos)
                  });
                } finally {
                  $i = i;
                }
              }
            }
          }
        }
      },
      restoreContext: function() {
        var $__5;
        for (var $i in R) {
          try {
            throw undefined;
          } catch (i) {
            i = $i;
            (($__5 = traceur.runtime.elementGet(this.R, i), traceur.runtime.elementGet(R, i).nthValue = $__5.nthValue, traceur.runtime.elementGet(R, i).value = $__5.value, $__5));
          }
        }
        analyzer.memRead = (function(addr, bits) {
          var $__6 = this.SPdiffAll(addr), i = traceur.runtime.elementGet($__6, 0), diff = traceur.runtime.elementGet($__6, 1);
          if (traceur.runtime.isnt(diff, NaN)) return this.readStack(diff, bits, traceur.runtime.elementGet(this.stack, i));
        }).bind(this);
        analyzer.memWrite = (function(addr, bits, v) {
          var $__6 = this.SPdiffAll(addr), i = traceur.runtime.elementGet($__6, 0), diff = traceur.runtime.elementGet($__6, 1);
          if (traceur.runtime.isnt(diff, NaN)) return this.writeStack(diff, bits, v, traceur.runtime.elementGet(this.stack, i)) !== false;
        }).bind(this);
      },
      preOp: function(x) {
        this.emit('preOp', x);
        PC.value = this.PC;
        this.PCwritten = false;
      },
      op: function(x) {
        this.emit('op', x);
        if (x.op == '=') {
          try {
            throw undefined;
          } catch (needsFreeze) {
            if (x.a == PC.lvalue) this.PCwritten = true; else if (x.a == SP.lvalue) {
              try {
                throw undefined;
              } catch (diff) {
                try {
                  throw undefined;
                } catch (i) {
                  try {
                    throw undefined;
                  } catch ($__5) {
                    {
                      $__5 = this.SPdiffAll(x.b);
                      i = traceur.runtime.elementGet($__5, 0);
                      diff = traceur.runtime.elementGet($__5, 1);
                    }
                    if (traceur.runtime.is(diff, NaN)) {
                      if (x.b.op == '+' && known(x.b.b)) this.SP0.push(x.b.a); else this.SP0.push(x.b);
                      this.stack.push({
                        down: [],
                        up: []
                      });
                    } else if (i != this.SP0.length - 1) {
                      this.SP0.splice(i + 1);
                      this.stack.splice(i + 1);
                    }
                  }
                }
              }
            }
            needsFreeze = (function(x) {
              var d = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): 0;
              return d >= 8 || x.fn == 'Mem' || x.a && needsFreeze(x.a, d + 1) || x.b && needsFreeze(x.b, d + 1) || x.args && x.args.some((function(x) {
                return needsFreeze(x, d + 1);
              }));
            });
            if (x.a.freeze && needsFreeze(x.b)) x.a.freeze(x.b); else x.a.value = x.b;
          }
        } else if (x.op == '<->') {
          try {
            throw undefined;
          } catch (b) {
            try {
              throw undefined;
            } catch (a) {
              {
                a = valueof(x.a);
                b = valueof(x.b);
              }
              this.op(Mov(x.a, b));
              this.op(Mov(x.b, a));
            }
          }
        }
      },
      postOp: function() {
        this.emit('postOp');
        if (this.PCwritten && PC.value != this.PCnext) {
          try {
            throw undefined;
          } catch (targetBlock) {
            try {
              throw undefined;
            } catch (savesPC) {
              console.log('-->', inspect(PC.value));
              savesPC = analyzer.memRead(valueof(SP), PC.bitsof) == this.PCnext;
              targetBlock = this.getJumpTarget(PC.value, savesPC);
              if (savesPC) {
                try {
                  throw undefined;
                } catch (updatedR) {
                  try {
                    throw undefined;
                  } catch (changedR0) {
                    try {
                      throw undefined;
                    } catch (stackMaxAccess) {
                      if (!targetBlock.returnPoints.length) throw new Error('Not returning from a function call ' + inspect(targetBlock));
                      stackMaxAccess = targetBlock.returnPoints.reduce((function(a, b) {
                        return ({stackMaxAccess: Math.max(a.stackMaxAccess, b.stackMaxAccess)});
                      })).stackMaxAccess;
                      {
                        try {
                          throw undefined;
                        } catch ($i) {
                          try {
                            throw undefined;
                          } catch ($stack) {
                            try {
                              throw undefined;
                            } catch ($diff) {
                              {
                                $diff = this.SPdiff(SP);
                                $stack = traceur.runtime.elementGet(this.stack, this.stack.length - 1).down;
                                $i = $diff;
                              }
                              for (; $i < $diff + stackMaxAccess; $i++) {
                                try {
                                  throw undefined;
                                } catch (i) {
                                  try {
                                    throw undefined;
                                  } catch (stack) {
                                    try {
                                      throw undefined;
                                    } catch (diff) {
                                      {
                                        diff = $diff;
                                        stack = $stack;
                                        i = $i;
                                      }
                                      try {
                                        if (traceur.runtime.elementGet(stack, ~i) && traceur.runtime.elementGet(stack, ~i).canBeArg) traceur.runtime.elementGet(stack, ~i).canBeArg = false;
                                      } finally {
                                        $diff = diff;
                                        $stack = stack;
                                        $i = i;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      changedR0 = {};
                      {
                        try {
                          throw undefined;
                        } catch (r) {
                          r = [];
                          for (var $i in R) {
                            try {
                              throw undefined;
                            } catch (i) {
                              i = $i;
                              if (traceur.runtime.elementGet(R, i).value == traceur.runtime.elementGet(this.R0, i)) {
                                traceur.runtime.elementSet(changedR0, i, traceur.runtime.elementGet(targetBlock.R0, i).value);
                                traceur.runtime.elementGet(targetBlock.R0, i).value = traceur.runtime.elementGet(R, i).value;
                                r.push(inspect(traceur.runtime.elementGet(R, i)));
                              }
                            }
                          }
                          if (r.length) console.log('->₀', r.join(', '));
                        }
                      }
                      for (var $i in R) {
                        try {
                          throw undefined;
                        } catch (i) {
                          i = $i;
                          if (traceur.runtime.isnt(traceur.runtime.elementGet(this.SPdiffAll(R[i].value), 1), NaN)) {
                            traceur.runtime.elementSet(changedR0, i, traceur.runtime.elementGet(targetBlock.R0, i).value);
                            traceur.runtime.elementGet(targetBlock.R0, i).value = traceur.runtime.elementGet(R, i).value;
                            console.log('->', traceur.runtime.elementGet(R, i), '=', traceur.runtime.elementGet(R, i).value);
                          }
                        }
                      }
                      updatedR = [];
                      for (var $i in R) {
                        try {
                          throw undefined;
                        } catch (SPdiff) {
                          try {
                            throw undefined;
                          } catch (SP0) {
                            try {
                              throw undefined;
                            } catch (i) {
                              i = $i;
                              ;
                              {
                                var $__1 = traceur.runtime.getIterator(targetBlock.returnPoints);
                                try {
                                  while ($__1.moveNext()) {
                                    try {
                                      throw undefined;
                                    } catch (x) {
                                      x = $__1.current;
                                      {
                                        try {
                                          throw undefined;
                                        } catch (diff) {
                                          try {
                                            throw undefined;
                                          } catch (j) {
                                            try {
                                              throw undefined;
                                            } catch ($__5) {
                                              try {
                                                throw undefined;
                                              } catch (v) {
                                                v = traceur.runtime.elementGet(x.R, i).value;
                                                if (v.frozenValue) v = v.frozenValue;
                                                v = valueof(v);
                                                {
                                                  $__5 = this.SPdiffAll(v);
                                                  j = traceur.runtime.elementGet($__5, 0);
                                                  diff = traceur.runtime.elementGet($__5, 1);
                                                }
                                                if (traceur.runtime.is(diff, NaN)) {
                                                  if (traceur.runtime.elementGet(R, i) != SP && v == traceur.runtime.elementGet(this.R0, i) && traceur.runtime.elementGet(R, i).value != traceur.runtime.elementGet(this.R0, i)) {
                                                    if (!SP0) {
                                                      SP0 = v;
                                                      SPdiff = 0;
                                                      continue;
                                                    } else (v != SP0 || SPdiff);
                                                    throw new Error(inspect(traceur.runtime.elementGet(R, i)) + ' differs ' + inspect(v) + ' vs ' + inspect(SP0) + ' + ' + SPdiff);
                                                  } else if (traceur.runtime.elementGet(R, i) == SP) {
                                                    if (targetBlock.returnPoints.length == 1) {
                                                      console.error('Using strange SP ' + j + ' ' + diff + ' ' + inspect(traceur.runtime.elementGet(x.R, i).value) + ' ' + inspect(v));
                                                      SP0 = v;
                                                      SPdiff = 0;
                                                      break;
                                                    } else throw new Error('SP is strange ' + j + ' ' + diff + ' ' + inspect(traceur.runtime.elementGet(x.R, i).value) + ' ' + inspect(v));
                                                  } else {
                                                    SP0 = null;
                                                    break;
                                                  }
                                                }
                                                if (!SP0) {
                                                  SP0 = traceur.runtime.elementGet(this.SP0, j);
                                                  SPdiff = diff;
                                                } else if (traceur.runtime.elementGet(this.SP0, j) != SP0 || diff != SPdiff) throw new Error(inspect(traceur.runtime.elementGet(R, i)) + ' differs ' + inspect(traceur.runtime.elementGet(x.SP0, j)) + ' + ' + diff + ' (' + inspect(x.start) + ') vs ' + inspect(SP0) + ' + ' + SPdiff + ', from ' + inspect(this.start) + ' for ' + inspect(targetBlock.start));
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                } finally {
                                  if ($__1.close) $__1.close();
                                }
                              }
                              if (SP0) {
                                this.op(valueof(Mov(traceur.runtime.elementGet(R, i), Add(SP0, SPdiff))));
                                updatedR.push(i);
                                console.log('<-', traceur.runtime.elementGet(R, i), '=', traceur.runtime.elementGet(R, i).value, '//', traceur.runtime.elementGet(targetBlock.returnPoints[0].R, i).value);
                              }
                            }
                          }
                        }
                      }
                      if (targetBlock.returnPoints.length == 1) {
                        try {
                          throw undefined;
                        } catch (diff) {
                          try {
                            throw undefined;
                          } catch (j) {
                            try {
                              throw undefined;
                            } catch (stack) {
                              try {
                                throw undefined;
                              } catch (SP0) {
                                try {
                                  throw undefined;
                                } catch ($__5) {
                                  {
                                    $__5 = traceur.runtime.elementGet(targetBlock.returnPoints, 0);
                                    SP0 = traceur.runtime.elementGet($__5.SP0, 0).value;
                                    stack = traceur.runtime.elementGet($__5.stack, 0);
                                  }
                                  {
                                    $__5 = this.SPdiffAll(SP0);
                                    j = traceur.runtime.elementGet($__5, 0);
                                    diff = traceur.runtime.elementGet($__5, 1);
                                  }
                                  ([stack].map((function(x, i) {
                                    var r = '';
                                    x.up.forEach((function(x, i) {
                                      if (x && !x.invalid) {
                                        try {
                                          throw undefined;
                                        } catch (saved) {
                                          saved = false;
                                          if (i && traceur.runtime.isnt(diff, NaN)) {
                                            this.writeStack(diff + i, x.bitsof, valueof(x.value), traceur.runtime.elementGet(this.stack, j));
                                            saved = true;
                                          }
                                          r = ',\n  ' + i + ': ' + inspect(x.value) + (saved ? ' // Saved': '') + r;
                                        }
                                      }
                                    }).bind(this));
                                    r = '[:' + inspect(traceur.runtime.elementGet(targetBlock.returnPoints[0].SP0, i)) + r;
                                    x.down.forEach((function(x, i) {
                                      if (x && !x.invalid) r += ',\n  ' + ~i + ': ' + inspect(x.value);
                                    }));
                                    return r + ']';
                                  }).bind(this)).join(',\n'));
                                }
                              }
                            }
                          }
                        }
                      }
                      (this.stack.map((function(x, i) {
                        var r = '';
                        x.up.forEach((function(x, i) {
                          if (x && !x.invalid) r = ',\n  ' + i + ': ' + inspect(x.value) + r;
                        }));
                        r = '[:' + inspect(traceur.runtime.elementGet(this.SP0, i)) + r;
                        x.down.forEach((function(x, i) {
                          if (x && !x.invalid) r += ',\n  ' + ~i + ': ' + inspect(x.value);
                        }));
                        return r + ']';
                      }).bind(this)).join(',\n'));
                      for (var $i in R) {
                        try {
                          throw undefined;
                        } catch (i) {
                          i = $i;
                          if (traceur.runtime.elementGet(R, i) != PC && traceur.runtime.is(updatedR.indexOf(i), - 1) && targetBlock.returnPoints.some((function(x) {
                            return traceur.runtime.elementGet(x.R, i).value != traceur.runtime.elementGet(x.R0, i);
                          }))) {
                            try {
                              throw undefined;
                            } catch (lvalue) {
                              console.log(("Changes " + inspect(traceur.runtime.elementGet(R, i)) + " <- {" + targetBlock.returnPoints.map((function(x) {
                                return inspect(valueof(traceur.runtime.elementGet(x.R, i).value));
                              })).join(', ') + "}"));
                              lvalue = lvalueof(traceur.runtime.elementGet(R, i));
                              if (lvalue.freeze) lvalue.freeze();
                            }
                          }
                        }
                      }
                      for (var $i in changedR0) {
                        try {
                          throw undefined;
                        } catch (i) {
                          i = $i;
                          traceur.runtime.elementGet(targetBlock.R0, i).value = traceur.runtime.elementGet(changedR0, i);
                        }
                      }
                    }
                  }
                }
              } else if (targetBlock == this.retPC) this.returns = true; else this.link = targetBlock;
            }
          }
        }
      },
      getJumpTarget: function(newPC) {
        var $__5;
        var savesPC = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): analyzer.memRead(valueof(SP), PC.bitsof) == this.PCnext;
        if (!known(newPC)) {
          if (newPC == this.retPC) {
            this.emit('returnPoint', this);
            return this.retPC;
          } else if (savesPC && newPC.fn == 'Function') {
            try {
              throw undefined;
            } catch (target) {
              target = newPC.block;
              if (!target) throw new Error('Cannot jump to function -> ' + inspect(newPC));
              return target;
            }
          } else if (savesPC) {
            try {
              throw undefined;
            } catch (pc) {
              try {
                throw undefined;
              } catch (k) {
                try {
                  throw undefined;
                } catch (j) {
                  try {
                    throw undefined;
                  } catch (i) {
                    try {
                      throw undefined;
                    } catch (stack) {
                      try {
                        throw undefined;
                      } catch (target) {
                        console.error('Unknown call, assuming arguments');
                        target = new Block({returnts: true});
                        target.SP.value = Add(traceur.runtime.elementGet(target.SP0, 0), sizeof(PC));
                        target.returnPoints.push(target);
                        {
                          stack = traceur.runtime.elementGet(this.stack, this.stack.length - 1).down;
                          i = this.SPdiff(valueof(SP)) + sizeof(PC);
                          j = i;
                          k = 0;
                          pc = this.PC;
                        }
                        while (j < 0) {
                          try {
                            throw undefined;
                          } catch (v) {
                            v = traceur.runtime.elementGet(stack, ~j);
                            if (!v || v.invalid || v.parent != this || !v.canBeArg) break;
                            if (pc > v.PCnext) k += pc - v.PCnext;
                            if (k > 12) {
                              console.error(("!!stack[-" + inspect(- j) + "]" + v.bitsof + " (" + k + ") ="), inspect(v.value));
                              break;
                            }
                            console.error(("stack[-" + inspect(- j) + "]" + v.bitsof + " (" + k + ") ="), inspect(v.value));
                            j += v.bitsof / 8;
                            pc = v.PC;
                          }
                        }
                        target.stackMaxAccess = j - i + sizeof(PC);
                        this.once('preOp', (function(x) {
                          if (x.some((function(x) {
                            return (x.op == '=' && x.a == SP);
                          }))) return;
                          console.error('Assuming callee cleans the stack (' + (j - i) + ')', x);
                          this.op(valueof(Mov(SP, Add(SP, j - i))));
                        }).bind(this));
                        return target;
                      }
                    }
                  }
                }
              }
            }
          } else {
            (this.stack.map((function(x, i) {
              var r = '';
              x.up.forEach((function(x, i) {
                if (x && !x.invalid) r = ',\n  ' + i + ': ' + inspect(x.value) + r;
              }));
              r = '[:' + inspect(traceur.runtime.elementGet(this.SP0, i)) + r;
              x.down.forEach((function(x, i) {
                if (x && !x.invalid) r += ',\n  ' + ~i + ': ' + inspect(x.value);
              }));
              return r + ']';
            }).bind(this)).join(',\n'));
            throw new Error('Unknown jump -> ' + inspect(newPC));
          }
        }
        this.saveContext();
        if (savesPC) console.group('0x' + newPC.toString(16).padLeft(8, '0'));
        var target = new Block({start: newPC}), returnPoint = (function(x) {
          return this.emit('returnPoint', x);
        }).bind(this);
        if (savesPC) target.writeStack(0, PC.bitsof, target.retPC); else {
          target.on('returnPoint', returnPoint);
          target.retPC = this.retPC;
          target.SP0 = this.SP0.slice();
          target.stack = this.stack.map((function(x) {
            return ({
              down: x.down.slice(),
              up: x.up.slice()
            });
          }));
          for (var $i in R) {
            try {
              throw undefined;
            } catch (i) {
              i = $i;
              if (traceur.runtime.isnt(traceur.runtime.elementGet(this.SPdiffAll(this.R[i].value), 1), NaN) || traceur.runtime.elementGet(R, i) != SP && traceur.runtime.elementGet(this.R, i).value == traceur.runtime.elementGet(this.R0, i) || traceur.runtime.elementGet(this.R, i).value.fn == 'Function')($__5 = traceur.runtime.elementGet(this.R, i), traceur.runtime.elementGet(target.R, i).value = $__5.value, traceur.runtime.elementGet(target.R, i).nthValue = $__5.nthValue, $__5);
              if (traceur.runtime.elementGet(R, i) != SP) traceur.runtime.elementSet(target.R0, i, traceur.runtime.elementGet(this.R0, i));
            }
          }
        }
        var newTarget = analyzer.getBlock(target);
        if (savesPC) console.groupEnd(); else {
          target.removeListener('returnPoint', returnPoint);
          if (newTarget != target) newTarget.returnPoints.forEach(returnPoint);
        }
        this.restoreContext();
        if (newTarget.inProgress && savesPC) {
          console.error(("Got inProgress block, with " + newTarget.returnPoints.length + " return points"));
          if (!newTarget.returnPoints.length) {
            newTarget.once('returnPoint', (function() {
              if (this.decoder) this.decoder();
            }).bind(this));
            throw new AnalysisPauseError('no return points');
          }
        }
        return newTarget;
      }
    }, $__proto, $__super, true);
    return $Block;
  }(EventEmitter);
  ;
  return analyzer = new (function($__super) {
    var $__proto = $__getProtoParent($__super);
    var Analyzer = ($__createClass)({
      constructor: function() {
        $__superCall(this, $__proto, "constructor", []);
        this.blocksVisited = [];
        this.arch = arch;
        this.Block = Block;
        for (var $i in R) {
          try {
            throw undefined;
          } catch (i) {
            i = $i;
            traceur.runtime.elementGet(R, i).lvalue = {
              inspect: (function() {
                return inspect(traceur.runtime.elementGet(R, i)) + traceur.runtime.elementGet(R, i).nthValue.toSubString();
              }),
              freeze: function(v) {
                var name = inspect(traceur.runtime.elementGet(R, i)) + (traceur.runtime.elementGet(R, i).nthValue++).toSubString();
                traceur.runtime.elementGet(R, i).value = {
                  frozenValue: v,
                  inspect: (function() {
                    return name;
                  })
                };
              },
              get value() {
                return traceur.runtime.elementGet(R, i).value;
              },
              set value(v) {
                traceur.runtime.elementGet(R, i).value = v;
              }
            };
          }
        }
        var $__5 = Mem, read = $__5.read, write = $__5.write;
        Mem.read = (function(addr, bits) {
          if (this.memRead) {
            var v = this.memRead(addr, bits);
            if (v !== null && v !== void 0) return v;
          }
          return read(addr, bits);
        }).bind(this);
        Mem.write = (function(addr, bits, v) {
          if (this.memWrite) {
            var r = this.memWrite(addr, bits, v);
            if (r) return r;
          }
          return write(addr, bits, v);
        }).bind(this);
      },
      getBlock: function(block) {
        var start = block.start;
        if (!known(start) || start < this.codeBase || start >= this.codeBase + this.codeBuffer.length) throw new Error('Block starting outside of codeBuffer bounds');
        start -= this.codeBase;
        if (traceur.runtime.elementGet(this.blocksVisited, start)) return traceur.runtime.elementGet(this.blocksVisited, start);
        if (!(block instanceof Block)) block = new Block(block);
        traceur.runtime.elementSet(this.blocksVisited, start, block);
        block.inProgress = true;
        block.decoderGenerator = this.decodeBlock(block);
        block.decoder = block.decoderGenerator.moveNext.bind(block.decoderGenerator);
        block.decoder();
        return block;
      },
      decodeBlock: function(block) {
        var $that = this;
        var $arguments = arguments;
        var $state = 93;
        var $storedException;
        var $finallyFallThrough;
        var asm;
        var bytes;
        var e;
        var err;
        var i;
        var j;
        var r;
        var s;
        var slice;
        var start;
        var targetPC;
        var v;
        var x;
        var $result = {moveNext: function($yieldSent) {
            while (true) try {
              switch ($state) {
                case 93:
                  start = traceur.runtime.elementGet($arguments, 1) !== (void 0) ? traceur.runtime.elementGet($arguments, 1): block.start - $that.codeBase;
                  $state = 94;
                  break;
                case 94:
                  block.restoreContext();
                  $state = 96;
                  break;
                case 96:
                  i = start;
                  $state = 88;
                  break;
                case 88:
                  if (i < $that.codeBuffer.length) {
                    $state = 64;
                    break;
                  } else {
                    $state = 90;
                    break;
                  }
                case 64:
                  block.PC = $that.codeBase + i;
                  $state = 65;
                  break;
                case 65:
                  [r = null, err = null];
                  $state = 67;
                  break;
                case 67:
                  try {
                    r = arch.dis($that.codeBuffer, i);
                  } catch (e) {
                    err = e;
                  }
                  $state = 69;
                  break;
                case 69:
                  if (!r || err) {
                    console.error('Failed at', $that.codeBuffer.slice(i));
                    if (arch.legacyDisasm) console.log(arch.legacyDisasm($that.codeBase + i, $that.codeBuffer.slice(i, i + 16)).trim());
                  }
                  $state = 71;
                  break;
                case 71:
                  if (err) throw err;
                  $state = 73;
                  break;
                case 73:
                  if (!r) {
                    $state = 0;
                    break;
                  } else {
                    $state = 1;
                    break;
                  }
                case 0:
                  $state = 104;
                  break;
                case 1:
                  [bytes = traceur.runtime.elementGet(r, 0), slice = $that.codeBuffer.slice(i, i + bytes), asm = ''];
                  $state = 75;
                  break;
                case 75:
                  if (arch.legacyDisasm) asm = ' // ' + arch.legacyDisasm($that.codeBase + i, slice).trim();
                  $state = 77;
                  break;
                case 77:
                  r = r.slice(1);
                  $state = 79;
                  break;
                case 79:
                  block.PCnext = block.PC + bytes;
                  $state = 81;
                  break;
                case 81:
                  block.preOp(r);
                  $state = 83;
                  break;
                case 83:
                  j = 0;
                  $state = 42;
                  break;
                case 42:
                  if (j < r.length) {
                    $state = 30;
                    break;
                  } else {
                    $state = 44;
                    break;
                  }
                case 41:
                  j++;
                  $state = 42;
                  break;
                case 30:
                  [x = traceur.runtime.elementGet(r, j), s = inspect(x), v = valueof(x)];
                  $state = 31;
                  break;
                case 31:
                  s = inspect(v) + ' // ' + s;
                  $state = 33;
                  break;
                case 33:
                  if (!j) s += asm;
                  $state = 35;
                  break;
                case 35:
                  if (v.fn == 'If') {
                    $state = 5;
                    break;
                  } else {
                    $state = 4;
                    break;
                  }
                case 5:
                  if (j != r.length - 1 || v.then.op != '=' || v.then.a != PC) throw new Error('Cannot handle conditional ' + inspect(v));
                  $state = 6;
                  break;
                case 6:
                  targetPC = valueof(v.then.b);
                  $state = 8;
                  break;
                case 8:
                  console.group('if(' + inspect(v.cond) + ') --> ' + inspect(targetPC) + ' /* ' + s + ' */');
                  $state = 10;
                  break;
                case 10:
                  block.linkCond = v.cond;
                  $state = 12;
                  break;
                case 12:
                  block.linkIf = block.getJumpTarget(targetPC);
                  $state = 14;
                  break;
                case 14:
                  console.groupEnd();
                  $state = 16;
                  break;
                case 16:
                  console.group('else');
                  $state = 18;
                  break;
                case 18:
                  block.link = block.getJumpTarget(block.PCnext);
                  $state = 20;
                  break;
                case 20:
                  console.groupEnd();
                  $state = 22;
                  break;
                case 22:
                  $that.decoder = $that.decoderGenerator = null;
                  $state = 24;
                  break;
                case 24:
                  block.saveContext();
                  $state = 26;
                  break;
                case 26:
                  block.inProgress = false;
                  $state = 28;
                  break;
                case 28:
                  $state = 104;
                  break;
                case 4:
                  block.op(v);
                  $state = 37;
                  break;
                case 37:
                  if (j) s = (j == r.length - 1 ? '└': '├').padLeft(13 + bytes * 2).padRight(31, '─') + s; else s = '0x' + block.PC.toString(16).padLeft(8, '0') + ' 0x' + slice.toString('hex').padRight(18) + s;
                  $state = 39;
                  break;
                case 39:
                  console.log(s);
                  $state = 41;
                  break;
                case 44:
                  $state = 57;
                  break;
                case 57:
                  block.postOp();
                  $state = 58;
                  break;
                case 58:
                  $that.emit('Block.postOp', block);
                  $state = 60;
                  break;
                case 60:
                  $state = 63;
                  break;
                case 61:
                  e = $storedException;
                  $state = 47;
                  break;
                case 47:
                  if (!(e instanceof AnalysisPauseError)) throw e;
                  $state = 48;
                  break;
                case 48:
                  console.error(e.toString());
                  $state = 50;
                  break;
                case 50:
                  block.saveContext();
                  $state = 52;
                  break;
                case 52:
                  $state = 104;
                  break;
                case 46:
                  block.restoreContext();
                  $state = 56;
                  break;
                case 63:
                  if (block.link || block.returns) {
                    $state = 84;
                    break;
                  } else {
                    $state = 85;
                    break;
                  }
                case 84:
                  $state = 90;
                  break;
                case 85:
                  i += bytes;
                  $state = 88;
                  break;
                case 90:
                  $that.decoder = $that.decoderGenerator = null;
                  $state = 98;
                  break;
                case 98:
                  block.saveContext();
                  $state = 100;
                  break;
                case 100:
                  block.inProgress = false;
                  $state = 102;
                  break;
                case 102:
                  $state = 104;
                  break;
                case 92:
                  $state = 104;
                case 104:
                  return false;
                case 103:
                  throw $storedException;
                default:
                  throw "traceur compiler bug: invalid state in state machine" + $state;
              }
            } catch ($caughtException) {
              $storedException = $caughtException;
              switch ($state) {
                case 57:
                  $state = 61;
                  break;
                case 58:
                  $state = 61;
                  break;
                case 60:
                  $state = 61;
                  break;
                default:
                  throw $storedException;
              }
            }
          }};
        traceur.runtime.addIterator($result);
        return $result;
      }
    }, $__proto, $__super, true);
    return Analyzer;
  }(EventEmitter));
});
if (process.argv.length < 3) console.error('Usage: analyzer FILE'), process.exit(1);
{
  try {
    throw undefined;
  } catch (write) {
    try {
      throw undefined;
    } catch (read) {
      try {
        throw undefined;
      } catch ($__5) {
        try {
          throw undefined;
        } catch (importsByAddr) {
          try {
            throw undefined;
          } catch (imports) {
            try {
              throw undefined;
            } catch (importHeaders) {
              try {
                throw undefined;
              } catch (isWin) {
                try {
                  throw undefined;
                } catch (codeSection) {
                  try {
                    throw undefined;
                  } catch (sections) {
                    try {
                      throw undefined;
                    } catch (asm) {
                      try {
                        throw undefined;
                      } catch (analyzer) {
                        try {
                          throw undefined;
                        } catch (fileName) {
                          try {
                            throw undefined;
                          } catch (entries) {
                            try {
                              throw undefined;
                            } catch (program) {
                              try {
                                throw undefined;
                              } catch (bin) {
                                try {
                                  throw undefined;
                                } catch (path) {
                                  try {
                                    throw undefined;
                                  } catch (fs) {
                                    try {
                                      throw undefined;
                                    } catch (r2) {
                                      {
                                        r2 = require('radare2.js');
                                        fs = require('fs');
                                        path = require('path');
                                      }
                                      bin = new r2.RBin();
                                      program = require('commander').option('-a, --arch <ARCH>').option('-b, --base <ADDRESS>', 'base address', parseInt).option('-e, --entry <ADDRESS>', 'entry point', parseInt);
                                      entries = [];
                                      program.on('entry', (function(x) {
                                        return entries.push(parseInt(x));
                                      }));
                                      program.parse(process.argv);
                                      fileName = traceur.runtime.elementGet(program.args, 0);
                                      if (!fileName) program.help();
                                      if (!bin.load(fileName, false)) {
                                        try {
                                          throw undefined;
                                        } catch (buffer) {
                                          ;
                                          try {
                                            buffer = fs.readFileSync(fileName);
                                          } catch (e) {
                                            console.error(e);
                                            process.exit(1);
                                          }
                                          console.error('r2 cannot open', fileName);
                                          if (!program.arch) {
                                            if (process.env.ARCH) program.arch = process.env.ARCH; else program.missingArgument('arch');
                                          }
                                          bin = {
                                            buffer: buffer,
                                            baseAddress: program.base || 0,
                                            arch: program.arch,
                                            bits: program.bits || 32,
                                            sections: [{
                                              name: '.text',
                                              rva: 0,
                                              offset: 0,
                                              size: buffer.length,
                                              srwx: 5
                                            }],
                                            imports: [],
                                            symbols: [],
                                            entries: entries.length ? entries.map((function(x) {
                                              return ({
                                                rva: x,
                                                offset: x
                                              });
                                            })): [{
                                              rva: 0,
                                              offset: 0
                                            }]
                                          };
                                        }
                                      } else {
                                        try {
                                          throw undefined;
                                        } catch (buffer) {
                                          try {
                                            throw undefined;
                                          } catch (binInfo) {
                                            try {
                                              throw undefined;
                                            } catch (rbin) {
                                              rbin = bin;
                                              binInfo = rbin.get_info();
                                              buffer = rbin.cur.buf.buf;
                                              buffer.type = Object.create(buffer.type);
                                              buffer.type.size = rbin.cur.buf.length;
                                              buffer = buffer.ref().deref();
                                              bin = {
                                                buffer: buffer,
                                                baseAddress: rbin.get_baddr(),
                                                arch: binInfo.arch,
                                                bits: binInfo.bits,
                                                sections: rbin.get_sections(),
                                                imports: rbin.get_imports(),
                                                symbols: rbin.get_symbols(),
                                                entries: rbin.get_entries()
                                              };
                                            }
                                          }
                                        }
                                      }
                                      analyzer = makeAnalyzer(require('./disasm/arch-' + bin.arch));
                                      asm = new r2.RAsm();
                                      if (asm.use(bin.arch) && asm.set_bits(bin.bits)) analyzer.arch.legacyDisasm = (function(PC, buffer) {
                                        asm.set_pc(PC);
                                        return asm.mdisassemble(buffer, buffer.length).buf_asm;
                                      });
                                      sections = [];
                                      bin.sections.forEach((function(x) {
                                        x = {
                                          name: x.name,
                                          addr: bin.baseAddress + x.rva,
                                          offset: x.offset,
                                          size: x.size,
                                          srwx: x.srwx
                                        };
                                        sections.push(x);
                                        if (x.srwx & 1) {
                                          if (codeSection || !x.size) console.error('Ignoring code section ' + x.name); else codeSection = x;
                                        }
                                      }));
                                      if (!codeSection) throw new Error('No code section');
                                      analyzer.codeBuffer = bin.buffer.slice(codeSection.offset, codeSection.offset + codeSection.size);
                                      analyzer.codeBase = analyzer.arch.PCbase = codeSection.addr;
                                      {
                                        isWin = /\.(dll|exe)$/i.test(fileName);
                                        importHeaders = [];
                                      }
                                      if (isWin) importHeaders.push(fs.readFileSync('windows.h'));
                                      {
                                        imports = [];
                                        importsByAddr = [];
                                      }
                                      console.group('Imports');
                                      bin.imports.forEach((function(x) {
                                        x = traceur.runtime.elementSet(importsByAddr, bin.baseAddress + x.rva, {
                                          name: x.name,
                                          addr: bin.baseAddress + x.rva,
                                          bind: x.bind,
                                          type: x.type
                                        });
                                        imports.push(x);
                                        var fn = x.name;
                                        if (isWin) fn = fn.replace(/^[a-z]+(32|64|)\.dll_/i, '');
                                        var args, fnRE = new RegExp('\\b' + fn + '\\b\\s*\\(([^()]*)\\)');
                                        {
                                          var $__1 = traceur.runtime.getIterator(importHeaders);
                                          try {
                                            while ($__1.moveNext()) {
                                              try {
                                                throw undefined;
                                              } catch (header) {
                                                header = $__1.current;
                                                if (args = fnRE.exec(header)) {
                                                  args = traceur.runtime.elementGet(args, 1).trim();
                                                  console.log(("Import " + x.name + "(" + args + ")@" + analyzer.arch.inspect(x.addr)));
                                                  if (!args || args == 'void') args = 0; else args = args.split(',').length * 4;
                                                  x.block = new analyzer.Block({
                                                    returns: true,
                                                    stackMaxAccess: 4 + args
                                                  });
                                                  x.block.emit('returnPoint', x.block);
                                                  if (bin.arch == 'x86') {
                                                    try {
                                                      throw undefined;
                                                    } catch (argVals) {
                                                      argVals = [];
                                                      {
                                                        try {
                                                          throw undefined;
                                                        } catch ($i) {
                                                          $i = 0;
                                                          for (; $i < args; $i += 4) {
                                                            try {
                                                              throw undefined;
                                                            } catch (i) {
                                                              i = $i;
                                                              try {
                                                                try {
                                                                  throw undefined;
                                                                } catch (arg) {
                                                                  arg = analyzer.arch.Mem(analyzer.arch.Add(traceur.runtime.elementGet(x.block.SP0, 0), 4 + i));
                                                                  arg.bitsof = 32;
                                                                  argVals.push(arg);
                                                                }
                                                              } finally {
                                                                $i = i;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                      x.block.R.EAX.value = {
                                                        args: argVals,
                                                        inspect: (function() {
                                                          return x.name;
                                                        }),
                                                        get value() {
                                                          var args = argVals.map((function(a) {
                                                            return analyzer.arch.valueof(a);
                                                          }));
                                                          return {
                                                            args: args,
                                                            inspect: (function() {
                                                              return x.name + '(' + args.map((function(a) {
                                                                return analyzer.arch.inspect(a);
                                                              })).join(', ') + ')';
                                                            })
                                                          };
                                                        }
                                                      };
                                                      x.block.SP.value = analyzer.arch.Add(traceur.runtime.elementGet(x.block.SP0, 0), args + 4);
                                                    }
                                                  }
                                                  return;
                                                }
                                              }
                                            }
                                          } finally {
                                            if ($__1.close) $__1.close();
                                          }
                                        }
                                        console.error('Unknown import ' + x.name);
                                      }));
                                      console.groupEnd();
                                      {
                                        $__5 = analyzer.arch.Mem;
                                        read = $__5.read;
                                        write = $__5.write;
                                      }
                                      analyzer.arch.Mem.read = (function(addr, bits) {
                                        var $__10;
                                        if (bits == 32) {
                                          try {
                                            throw undefined;
                                          } catch (imp) {
                                            imp = traceur.runtime.elementGet(importsByAddr, addr);
                                            if (imp) return {
                                              fn: 'Function',
                                              block: imp.block,
                                              inspect: (function() {
                                                return imp.name + ' (' + imp.bind + ' ' + imp.type + ')';
                                              })
                                            };
                                          }
                                        }
                                        {
                                          var $__1 = traceur.runtime.getIterator(sections);
                                          try {
                                            while ($__1.moveNext()) {
                                              try {
                                                throw undefined;
                                              } catch (x) {
                                                x = $__1.current;
                                                if (x.addr <= addr && addr < x.addr + x.size) {
                                                  if (x.srwx & 2) return;
                                                  return ($__10 = bin.buffer, traceur.runtime.elementGet($__10, 'readUInt' + bits + (bits == 8 ? '': 'LE')).call($__10, addr - x.addr + x.offset));
                                                }
                                              }
                                            }
                                          } finally {
                                            if ($__1.close) $__1.close();
                                          }
                                        }
                                        return read(addr, bits);
                                      });
                                      var symbols = [];
                                      bin.symbols.forEach((function(x) {
                                        console.log('Symbol %s: fw=%s bind=%s type=%s addr=%s offset=%s size=%d ordinal=%d', x.name, x.forwarder, x.bind, x.type, (bin.baseAddress + x.rva).toString(16), x.offset.toString(16), x.size, x.ordinal);
                                        if (x.type == 'FUNC') symbols.push({
                                          name: x.name,
                                          addr: bin.baseAddress + x.rva
                                        });
                                      }));
                                      bin.entries.forEach((function(x) {
                                        console.log('Entry: addr=%s offset=%s', (bin.baseAddress + x.rva).toString(16), x.offset.toString(16));
                                        symbols.push({
                                          name: 'entry',
                                          addr: bin.baseAddress + x.rva
                                        });
                                      }));
                                      if (!symbols.length) console.error('No usable symbols'), process.exit(1);
                                      var t = process.hrtime(), decodedInstructions = 0, decodedBytes = 0;
                                      analyzer.on('Block.postOp', (function(block) {
                                        decodedInstructions++;
                                        decodedBytes += block.PCnext - block.PC;
                                      }));
                                      process.on('exit', (function() {
                                        t = process.hrtime(t);
                                        console.log(("Decoded " + decodedInstructions + " instructions (" + Math.round(decodedBytes / 1024 * 100) / 100 + "KB) in " + (traceur.runtime.elementGet(t, 0) + traceur.runtime.elementGet(t, 1) / 1e9) + "s"));
                                      }));
                                      process.on('SIGINT', (function() {
                                        return process.exit();
                                      }));
                                      symbols.forEach((function(symbol) {
                                        var mainBlock = new analyzer.Block({start: symbol.addr});
                                        console.log('Analyzing ' + symbol.name + '@' + symbol.addr.toString(16).padLeft(8, '0'));
                                        mainBlock.writeStack(0, analyzer.arch.PC.bitsof, mainBlock.retPC);
                                        try {
                                          analyzer.getBlock(mainBlock);
                                        } catch (e) {
                                          if (typeof e === 'object') e = e.stack;
                                          console.error(e);
                                          while (console.groupEnd() !== false);
                                        }
                                      }));
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//@ sourceMappingURL=analyzer.map