!global.traceur && (0,eval)(require('fs').readFileSync(__dirname+'/deps/traceur-compiler/bin/traceur.js', 'utf8'));
var EventEmitter = require('events').EventEmitter;
String.prototype.padLeft = function padLeft(n, p) {
  p = p || ' ';
  var s = this.toString();
  while (s.length < n) s = p + s;
  return s;
};
String.prototype.padRight = function padRight(n, p) {
  p = p || ' ';
  var s = this.toString();
  while (s.length < n) s += p;
  return s;
};
Number.prototype.toSubString = function toSubString() {
  return this.toString().replace(/[0-9]/g, function(x) {
    return String.fromCharCode('₀'.charCodeAt() + (+ x));
  });
};
var analyzer = new EventEmitter;
analyzer.on('useArch', function(arch) {
  this.arch = arch;
  for (var $i in arch.R) {
    try {
      throw undefined;
    } catch (i) {
      i = $i;
      traceur.runtime.elementGet(arch.R, i).lvalue = null;
    }
  }
  for (var $i in arch.F) {
    try {
      throw undefined;
    } catch (i) {
      i = $i;
      traceur.runtime.elementGet(arch.F, i).lvalue = null;
    }
  }
});
analyzer.on('L1.initContext', function(ctx) {
  var arch = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): this.arch;
  for (var $i in arch.R) {
    try {
      throw undefined;
    } catch (i) {
      i = $i;
      traceur.runtime.elementGet(arch.R, i).nthValue = 0;
      traceur.runtime.elementGet(arch.R, i).value = {
        bitsof: traceur.runtime.elementGet(arch.R, i).bitsof,
        signed: traceur.runtime.elementGet(arch.R, i).signed,
        inspect: (function() {
          return arch.inspect(traceur.runtime.elementGet(arch.R, i)) + '₀';
        })
      };
    }
  }
  for (var $i in arch.F) {
    try {
      throw undefined;
    } catch (i) {
      i = $i;
      traceur.runtime.elementGet(arch.F, i).nthValue = 0;
      traceur.runtime.elementGet(arch.F, i).value = {
        bitsof: traceur.runtime.elementGet(arch.F, i).bitsof,
        signed: traceur.runtime.elementGet(arch.F, i).signed,
        inspect: (function() {
          return arch.inspect(traceur.runtime.elementGet(arch.F, i)) + '₀';
        })
      };
    }
  }
  ctx.SP0 = arch.SP.value;
  ctx.retIP = {inspect: (function() {
      return 'ret' + arch.inspect(arch.IP);
    })};
  var $__1 = arch.Mem, read = $__1.read, write = $__1.write;
  arch.Mem.read = (function(addr, bits) {
    if (addr == ctx.SP0) return ctx.retIP;
    return read(addr, bits);
  });
});
analyzer.on('L1.saveContext', function(ctx) {
  var arch = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): this.arch;
  ctx.R = {};
  ctx.F = {};
  for (var $i in arch.R) {
    try {
      throw undefined;
    } catch (i) {
      i = $i;
      traceur.runtime.elementSet(ctx.R, i, {
        nthValue: traceur.runtime.elementGet(arch.R, i).nthValue,
        value: traceur.runtime.elementGet(arch.R, i).value
      });
    }
  }
  for (var $i in arch.F) {
    try {
      throw undefined;
    } catch (i) {
      i = $i;
      traceur.runtime.elementSet(ctx.F, i, {
        nthValue: traceur.runtime.elementGet(arch.F, i).nthValue,
        value: traceur.runtime.elementGet(arch.F, i).value
      });
    }
  }
  ctx.SPdiff = null;
  if (arch.SP.value) {
    if (arch.SP.value == ctx.SP0) ctx.SPdiff = 0; else if (arch.SP.value.op == '+' && arch.SP.value.a == ctx.SP0 && arch.known(arch.SP.value.b)) ctx.SPdiff = arch.SP.value.b;
  }
});
analyzer.on('L1.restoreContext', function(ctx) {
  var $__1, $__2;
  var arch = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): this.arch;
  for (var $i in arch.R) {
    try {
      throw undefined;
    } catch (i) {
      i = $i;
      (($__1 = traceur.runtime.elementGet(ctx.R, i), traceur.runtime.elementGet(arch.R, i).nthValue = $__1.nthValue, traceur.runtime.elementGet(arch.R, i).value = $__1.value, $__1));
    }
  }
  for (var $i in arch.F) {
    try {
      throw undefined;
    } catch (i) {
      i = $i;
      (($__2 = traceur.runtime.elementGet(ctx.F, i), traceur.runtime.elementGet(arch.F, i).nthValue = $__2.nthValue, traceur.runtime.elementGet(arch.F, i).value = $__2.value, $__2));
    }
  }
  ctx.R = ctx.F = ctx.SPdiff = null;
});
analyzer.on('L1.preOp', function(ctx) {
  var arch = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): this.arch;
  arch.IP.value = ctx.IP;
  ctx.IPwritten = false;
});
analyzer.on('L1.op', function(ctx, x) {
  var arch = traceur.runtime.elementGet(arguments, 2) !== (void 0) ? traceur.runtime.elementGet(arguments, 2): this.arch;
  if (x.op == '=') {
    try {
      throw undefined;
    } catch (hasMem) {
      hasMem = (function(x) {
        return x.fn == 'Mem' || x.a && hasMem(x.a) || x.b && hasMem(x.b) || x.args && x.args.some(hasMem);
      });
      if (!hasMem(x.a) && hasMem(x.b)) x.a.value = {
        bitsof: x.a.bitsof,
        signed: x.a.signed,
        inspect: (function() {
          return arch.inspect(x.a) + (++x.a.nthValue).toSubString();
        })
      }; else x.a.value = x.b;
      if (x.a == arch.IP) ctx.IPwritten = true;
    }
  }
});
analyzer.blockDepth = 0;
analyzer.indent = '';
analyzer.on('L1.postOp', function(ctx) {
  var arch = traceur.runtime.elementGet(arguments, 1) !== (void 0) ? traceur.runtime.elementGet(arguments, 1): this.arch;
  if (ctx.IPwritten && arch.IP.value != ctx.IPnext) {
    if (arch.IP.value == ctx.IP) throw new Error('Infinite loop');
    console.log((this.indent + "-->"), arch.inspect(arch.IP.value));
    if (!arch.known(arch.IP.value)) {
      if (arch.IP.value == ctx.retIP) ctx.returns = true; else {
        console.error('Unknown jump, ending block');
        ctx.returns = true;
      }
    } else {
      try {
        throw undefined;
      } catch (newCtx) {
        try {
          throw undefined;
        } catch (oldIdent) {
          if (this.blockDepth++ >= 5) throw new Error('Nested too deep');
          if (arch.IP.value < ctx.base || arch.IP.value >= ctx.base + ctx.end) throw new Error('Jump to unknown');
          this.emit('L1.saveContext', ctx);
          oldIdent = this.indent;
          this.indent += '    ';
          newCtx = this.decodeBlock(ctx.base, ctx.buf, arch.IP.value - ctx.base, ctx.end);
          this.indent = oldIdent;
          this.blockDepth--;
          this.emit('L1.restoreContext', ctx);
          if (!arch.known(newCtx.SPdiff)) console.error('Missing stack difference!'); else arch.SP.value = arch.Add(arch.SP.value, newCtx.SPdiff);
        }
      }
    }
  }
});
analyzer.decodeBlock = function decodeBlock(base, buf) {
  var start = traceur.runtime.elementGet(arguments, 2) !== (void 0) ? traceur.runtime.elementGet(arguments, 2): 0;
  var end = traceur.runtime.elementGet(arguments, 3) !== (void 0) ? traceur.runtime.elementGet(arguments, 3): buf.length;
  var ctx = {
    base: base,
    buf: buf,
    end: end
  };
  console.log(("\n" + this.indent + ">>>"));
  this.emit('L1.initContext', ctx);
  for (var i = start; i < end;) {
    ctx.IP = base + i;
    this.emit('L1.preOp', ctx);
    var r = null, err = null;
    try {
      r = this.arch.dis(buf, i);
    } catch (e) {
      err = e;
    }
    if (!r || err) console.error('Failed at', buf.slice(i));
    if (err) throw err;
    if (!r) return ctx;
    var bytes = traceur.runtime.elementGet(r, 0);
    ctx.IPnext = ctx.IP + bytes;
    r = r.slice(1).map((function(x, i) {
      var v = this.arch.valueof(x);
      var s = this.arch.inspect(v) + ' // ' + this.arch.inspect(x);
      this.emit('L1.op', ctx, v);
      return i ? ''.padRight(8 + i) + '╲'.padRight(18 - i, i == r.length - 1 ? '_': ' ') + ' ' + s: s;
    }).bind(this)).join('\n' + this.indent);
    console.log(this.indent + (base + i).toString(16).padLeft(8, '0'), buf.slice(i, i + bytes).toString('hex').padRight(18) + r);
    this.emit('L1.postOp', ctx);
    if (ctx.returns) return console.log((this.indent + "<<<\n")), this.emit('L1.saveContext', ctx), ctx;
    i += bytes;
  }
  return ctx;
};
if (process.argv.length < 3) console.error('Usage: analyzer FILE'), process.exit(1);
{
  try {
    throw undefined;
  } catch (write) {
    try {
      throw undefined;
    } catch (read) {
      try {
        throw undefined;
      } catch ($__2) {
        try {
          throw undefined;
        } catch (sections) {
          try {
            throw undefined;
          } catch (arch) {
            try {
              throw undefined;
            } catch (buf) {
              try {
                throw undefined;
              } catch (binInfo) {
                try {
                  throw undefined;
                } catch (baseAddress) {
                  try {
                    throw undefined;
                  } catch (fileName) {
                    try {
                      throw undefined;
                    } catch (b) {
                      try {
                        throw undefined;
                      } catch (r2) {
                        r2 = require('radare2.js');
                        {
                          b = new r2.RBin();
                          fileName = traceur.runtime.elementGet(process.argv, 2);
                        }
                        if (!b.load(fileName, false)) console.error('Cannot open ' + fileName), process.exit(1);
                        {
                          baseAddress = b.get_baddr();
                          binInfo = b.get_info();
                          buf = b.cur.buf.buf;
                        }
                        buf.type = Object.create(buf.type);
                        buf.type.size = b.cur.buf.length;
                        buf = buf.ref().deref();
                        arch = require('./disasm/arch-' + binInfo.arch);
                        analyzer.emit('useArch', arch);
                        sections = [];
                        b.get_sections().forEach((function(x) {
                          return sections.push({
                            name: x.name,
                            offset: x.offset,
                            size: x.size,
                            srwx: x.srwx
                          });
                        }));
                        {
                          $__2 = arch.Mem;
                          read = $__2.read;
                          write = $__2.write;
                        }
                        arch.Mem.read = (function(addr, bits) {
                          var $__3;
                          if (baseAddress <= addr && addr < baseAddress + buf.length) {
                            try {
                              throw undefined;
                            } catch (a) {
                              a = addr - baseAddress;
                              {
                                var $__0 = traceur.runtime.getIterator(sections);
                                try {
                                  while ($__0.moveNext()) {
                                    try {
                                      throw undefined;
                                    } catch (x) {
                                      x = $__0.current;
                                      if (x.offset <= a && a < x.offset + x.size) {
                                        if (x.srwx & 2) break;
                                        return ($__3 = buf, traceur.runtime.elementGet($__3, 'readUInt' + bits + 'LE').call($__3, a));
                                      }
                                    }
                                  }
                                } finally {
                                  if ($__0.close) $__0.close();
                                }
                              }
                            }
                          }
                          return read(addr, bits);
                        });
                        var symbol;
                        b.get_symbols().forEach((function(x) {
                          if (x.type != 'FUNC') return;
                          if (symbol) console.error('Ignoring ' + x.name + '@' + (baseAddress + x.offset).toString(16).padLeft(8, '0')); else symbol = x;
                        }));
                        if (!symbol) console.error('No usable symbols'), process.exit(1);
                        console.log('Analyzing ' + symbol.name + '@' + (baseAddress + symbol.offset).toString(16).padLeft(8, '0'));
                        var t = process.hrtime(), decodedInstructions = 0, decodedBytes = 0;
                        analyzer.on('L1.postOp', (function(ctx) {
                          decodedInstructions++;
                          decodedBytes += ctx.IPnext - ctx.IP;
                        }));
                        process.on('exit', (function() {
                          t = process.hrtime(t);
                          console.log(("Decoded " + decodedInstructions + " instructions (" + Math.round(decodedBytes / 1024 * 100) / 100 + "KB) in " + (traceur.runtime.elementGet(t, 0) + traceur.runtime.elementGet(t, 1) / 1e9) + "s"));
                        }));
                        process.on('SIGINT', (function() {
                          return process.exit();
                        }));
                        try {
                          analyzer.decodeBlock(baseAddress, buf, symbol.offset);
                        } finally {
                          process.emit('exit');
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//@ sourceMappingURL=analyzer.map